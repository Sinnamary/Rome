<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Rome 2026</title>
  <link rel="icon" type="image/svg+xml" href="favicon.svg" />

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
          integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; width: 100%; }

    /* Numbered circle marker (DivIcon) */
    .num-marker{
      width: 32px; height: 32px;
      border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
      font: 700 14px/1 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: #fff;
      border: 2px solid rgba(255,255,255,0.9);
      box-shadow: 0 2px 8px rgba(0,0,0,0.35);
    }
    .prio-haute { background: #c62828; }
    .prio-moyenne { background: #ef6c00; }
    .prio-basse { background: #2e7d32; }
    .prio-defaut { background: #0d47a1; }

    /* H√©bergement marker (ordre 0.0) */
    .hebergement-marker{
      width: 40px; height: 40px;
      border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
      font-size: 24px;
      background: #1e3a8a;
      border: 3px solid rgba(255,255,255,0.95);
      box-shadow: 0 3px 10px rgba(0,0,0,0.4);
    }

    /* Popup layout */
    .popup h3 { margin: 0 0 6px 0; font-size: 16px; }
    .popup .meta { margin: 0; padding: 0; list-style: none; }
    .popup .meta li { margin: 2px 0; }
    .badge {
      display: inline-block; padding: 2px 8px; border-radius: 999px;
      font-size: 12px; font-weight: 600; color: #fff; vertical-align: middle;
    }
    .badge-haute { background:#c62828; }
    .badge-moyenne { background:#ef6c00; }
    .badge-basse { background:#2e7d32; }
    .badge-defaut { background:#0d47a1; }
    .muted { color: #555; }
    .popup a { word-break: break-all; }
    .route-line {
      cursor: pointer;
      transition: opacity 0.2s;
    }
    
    .route-line:hover {
      opacity: 1 !important;
      stroke-width: 5 !important;
    }
    
    .leaflet-control-layers {
      background: white;
      border-radius: 4px;
      box-shadow: 0 1px 5px rgba(0,0,0,0.4);
    }
    
    .leaflet-control-layers-overlays label {
      display: block;
      padding: 4px 8px;
      cursor: pointer;
    }
    
    .leaflet-control-layers-overlays label:hover {
      background-color: #f0f0f0;
    }
    /* Styles pour le calque hop-on hop-off */
    .hoponhopoff-route {
      cursor: pointer;
    }
    
    .hoponhopoff-route:hover {
      opacity: 1;
      stroke-width: 6;
    }
    
    .hoponhopoff-stop-icon {
      background: transparent;
      border: none;
    }
    
    .hoponhopoff-stop-marker {
      width: 32px;
      height: 32px;
      background: transparent;
      border: none;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: transform 0.2s ease;
      position: relative;
    }
    
    .hoponhopoff-stop-marker::before {
      content: 'üöå';
      font-size: 32px;
      line-height: 1;
      filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
    }
    
    .hoponhopoff-stop-marker:hover {
      transform: scale(1.2);
    }
    /* Panneau de routage interactif */
    .routing-interactive-panel {
      position: absolute;
      top: 10px;
      left: 10px;
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      z-index: 1000;
      max-width: 300px;
      font-family: system-ui, -apple-system, sans-serif;
      font-size: 14px;
    }
    .routing-interactive-panel.active {
      border: 2px solid #2563eb;
    }
    .routing-btn {
      padding: 6px 12px;
      margin: 2px;
      border: 1px solid #ccc;
      border-radius: 5px;
      background: #fff;
      cursor: pointer;
      font-size: 13px;
    }
    .routing-btn:hover {
      background: #f0f0f0;
    }
    .routing-btn.active {
      background: #2563eb;
      color: white;
      border-color: #2563eb;
    }
    .interactive-route-line {
      cursor: pointer;
    }
    .routing-selected-marker {
      z-index: 1000 !important;
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <script>
    // ============================================================
    // MODULE ROUTES - Gestion des calques de trajets
    // ============================================================
    // Ce code est compl√®tement ind√©pendant du code principal
    // Il g√®re uniquement l'affichage des trajets entre les points
        class RouteLayerManager {
      constructor(map) {
        this.map = map;
        this.routeLayers = new Map();
        this.pointLayers = new Map();
        this.dayColors = ["#2563eb", "#16a34a", "#ea580c", "#9333ea", "#dc2626", "#0891b2", "#ca8a04"];
        this.layerControl = null;
      }
      parseDayFromOrder(orderStr) {
        if (!orderStr || typeof orderStr !== 'string') return null;
        // G√©rer l'ordre 0.0 (h√©bergement) - utiliser la date pour d√©terminer le jour
        if (orderStr === '0.0' || orderStr === '0' || parseFloat(orderStr) === 0.0) {
          return 0; // Retourner 0 pour indiquer que c'est un h√©bergement
        }
        const match = orderStr.match(/^(\d+)\./);
        return match ? parseInt(match[1], 10) : null;
      }
      
      parseVisitFromOrder(orderStr) {
        if (!orderStr || typeof orderStr !== 'string') return null;
        const match = orderStr.match(/\.(\d+)$/);
        return match ? parseInt(match[1], 10) : null;
      }
      calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371000;
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLon = (lon2 - lon1) * Math.PI / 180;
        const a = 
          Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
          Math.sin(dLon / 2) * Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
      }
      
      formatDistance(meters) {
        if (meters < 1000) {
          return Math.round(meters) + " m";
        }
        return (meters / 1000).toFixed(2) + " km";
      }
      
      parseDistance(distanceStr) {
        // Parse une distance au format "30.5 km" ou "850 m" en m√®tres
        if (!distanceStr || typeof distanceStr !== 'string') return null;
        const str = distanceStr.trim().toLowerCase();
        // Regex pour km: nombre suivi de "km"
        const kmRegex = /([\d.]+)\s*km/;
        const kmMatch = str.match(kmRegex);
        if (kmMatch) {
          return parseFloat(kmMatch[1]) * 1000;
        }
        // Regex pour m: nombre suivi de "m" (mais pas "km")
        const mRegex = /([\d.]+)\s*m(?!m)/;
        const mMatch = str.match(mRegex);
        if (mMatch) {
          return parseFloat(mMatch[1]);
        }
        // Essayer de parser comme nombre simple (suppos√© en km)
        const numRegex = /([\d.]+)/;
        const numMatch = str.match(numRegex);
        if (numMatch) {
          const num = parseFloat(numMatch[1]);
          // Si < 10, supposer km, sinon m√®tres
          return num < 10 ? num * 1000 : num;
        }
        return null;
      }
      
      calculateTravelTime(distanceMeters, transport) {
        // Vitesses moyennes en m/s selon le moyen de transport
        const speeds = {
          'marche': 1.4,      // 5 km/h = 1.4 m/s
          'pied': 1.4,        // 5 km/h = 1.4 m/s
          'velo': 4.2,        // 15 km/h = 4.2 m/s
          'v√©lo': 4.2,        // 15 km/h = 4.2 m/s
          'metro': 8.3,       // 30 km/h = 8.3 m/s
          'm√©tro': 8.3,       // 30 km/h = 8.3 m/s
          'bus': 6.9,         // 25 km/h = 6.9 m/s
          'train': 13.9,      // 50 km/h = 13.9 m/s
          'voiture': 11.1,    // 40 km/h en ville = 11.1 m/s
          'taxi': 11.1,       // 40 km/h en ville = 11.1 m/s
          'default': 1.4      // Par d√©faut: marche (5 km/h)
        };
        
        if (!distanceMeters || distanceMeters <= 0) return null;
        
        const transportLower = (transport || '').toLowerCase().trim();
        const speed = speeds[transportLower] || speeds['default'];
        const timeSeconds = distanceMeters / speed;
        const timeMinutes = Math.round(timeSeconds / 60);
        
        if (timeMinutes < 1) return '< 1 min';
        if (timeMinutes < 60) return timeMinutes + ' min';
        const hours = Math.floor(timeMinutes / 60);
        const minutes = timeMinutes % 60;
        return hours + 'h' + (minutes > 0 ? minutes + 'min' : '');
      }
      createRouteLine(point1, point2, color) {
        const lat1 = point1.lat;
        const lon1 = point1.lon;
        const lat2 = point2.lat;
        const lon2 = point2.lon;
        
        // Utiliser la distance manuelle si pr√©sente, sinon calculer automatiquement
        let distanceText;
        let distanceMeters = null;
        if (point2.distance && point2.distance.trim() !== '') {
          // Distance manuelle renseign√©e dans le fichier Excel
          distanceText = point2.distance.trim();
          distanceMeters = this.parseDistance(distanceText);
        } else {
          // Calculer automatiquement la distance √† vol d'oiseau
          distanceMeters = this.calculateDistance(lat1, lon1, lat2, lon2);
          distanceText = this.formatDistance(distanceMeters);
        }
        
        // R√©cup√©rer le temps de trajet et le transport
        const tempsTrajet = point2.temps_trajet || '';
        const transport = point2.transport || '';
        
        // Calculer le temps de trajet si absent
        let tempsTrajetText = '';
        if (tempsTrajet && tempsTrajet.trim() !== '') {
          // Temps renseign√© manuellement
          tempsTrajetText = tempsTrajet.trim();
        } else if (distanceMeters && distanceMeters > 0) {
          // Calculer le temps bas√© sur la distance et le moyen de transport
          const transportMode = transport || 'marche'; // Par d√©faut: marche
          const calculatedTime = this.calculateTravelTime(distanceMeters, transportMode);
          if (calculatedTime) {
            tempsTrajetText = calculatedTime + ' (estim√©)';
          }
        }
        
        const polyline = L.polyline(
          [[lat1, lon1], [lat2, lon2]],
          {
            color: color,
            weight: 4,
            opacity: 0.7,
            dashArray: '10, 5',
            className: 'route-line'
          }
        );
        
        // Construire le contenu de la popup
        let popupLines = [
          '<strong>' + point1.order + ' ‚Üí ' + point2.order + '</strong>',
          '<hr style="margin: 5px 0; border: none; border-top: 1px solid #ddd;">'
        ];
        
        // Distance
        popupLines.push('<span style="color: #666;"><strong>Distance:</strong> ' + distanceText + '</span>');
        
        // Temps de trajet
        if (tempsTrajetText) {
          popupLines.push('<span style="color: #666;"><strong>Temps:</strong> ' + tempsTrajetText + '</span>');
        }
        
        // Moyen de transport
        if (transport && transport.trim() !== '') {
          const transportDisplay = transport.charAt(0).toUpperCase() + transport.slice(1).toLowerCase();
          popupLines.push('<span style="color: #666;"><strong>Transport:</strong> ' + transportDisplay + '</span>');
        }
        
        const popupContent = '<div style="text-align: center; padding: 5px;">' + popupLines.join('<br>') + '</div>';
        polyline.bindPopup(popupContent);
        
        return polyline;
      }
      groupPointsByDay(features) {
        const pointsByDay = new Map();
        
        // D'abord, collecter toutes les dates pour mapper les h√©bergements (ordre 0.0) aux jours
        const dateToDayMap = new Map();
        features.forEach((feature) => {
          const props = feature.properties || {};
          const order = String(props.ordre || props.numero || props.visite || '');
          const date = props.date || '';
          // Si ce n'est pas un h√©bergement, extraire le jour de l'ordre
          if (order !== '0.0' && order !== '0' && parseFloat(order) !== 0.0) {
            const day = this.parseDayFromOrder(order);
            if (day !== null && day !== 0 && date) {
              // Mapper la date au jour pour les points normaux
              if (!dateToDayMap.has(date)) {
                dateToDayMap.set(date, day);
              }
            }
          }
        });
        
        features.forEach((feature, index) => {
          const props = feature.properties || {};
          const order = String(props.ordre || props.numero || props.visite || (index + 1));
          const date = props.date || '';
          let day = this.parseDayFromOrder(order);
          
          // Si c'est un h√©bergement (ordre 0.0), utiliser la date pour d√©terminer le jour
          if (day === 0) {
            // Chercher le jour correspondant √† cette date
            day = dateToDayMap.get(date);
            // Si pas trouv√©, essayer de d√©duire du premier point non-h√©bergement de cette date
            if (!day) {
              // Parcourir les features pour trouver le premier point non-h√©bergement de cette date
              for (let i = 0; i < features.length; i++) {
                const f = features[i];
                const p = f.properties || {};
                const o = String(p.ordre || p.numero || p.visite || '');
                const d = p.date || '';
                if (d === date && o !== '0.0' && o !== '0' && parseFloat(o) !== 0.0) {
                  day = this.parseDayFromOrder(o);
                  if (day !== null && day !== 0) {
                    dateToDayMap.set(date, day);
                    break;
                  }
                }
              }
            }
            // Si toujours pas trouv√©, utiliser 1 par d√©faut
            if (!day) day = 1;
          }
          
          if (day === null) return;
          
          const coords = feature.geometry && feature.geometry.coordinates;
          if (!coords || coords.length < 2) return;
          
          const point = {
            order: order,
            day: day,
            visit: this.parseVisitFromOrder(order),
            lat: coords[1],
            lon: coords[0],
            name: props.name || 'Point ' + order,
            temps_trajet: props.temps_trajet || '',
            distance: props.distance || '',
            transport: props.transport || '',
            index: index,
            isHebergement: (order === '0.0' || order === '0' || parseFloat(order) === 0.0)
          };
          
          if (!pointsByDay.has(day)) {
            pointsByDay.set(day, []);
          }
          pointsByDay.get(day).push(point);
        });
        
        pointsByDay.forEach((points, day) => {
          points.sort((a, b) => {
            // Pour les h√©bergements (ordre 0.0), pr√©server l'ordre original (index)
            if (a.isHebergement && b.isHebergement) {
              return a.index - b.index;
            }
            if (a.isHebergement) {
              // H√©bergement avant les points normaux (sera ajust√© selon le jour dans le tri final)
              return -1;
            }
            if (b.isHebergement) {
              // Points normaux apr√®s les h√©bergements
              return 1;
            }
            
            // Pour les points normaux, utiliser le num√©ro de visite
            if (a.visit === null && b.visit === null) return 0;
            if (a.visit === null) return 1;
            if (b.visit === null) return -1;
            return a.visit - b.visit;
          });
          
          // Ajuster l'ordre des h√©bergements selon le jour
          const allDays = Array.from(pointsByDay.keys()).sort((x, y) => x - y);
          const isFirstDay = day === allDays[0];
          const isLastDay = day === allDays[allDays.length - 1];
          
          // S√©parer les h√©bergements des points normaux
          const hebergements = points.filter(p => p.isHebergement);
          const normalPoints = points.filter(p => !p.isHebergement);
          
          if (hebergements.length > 0) {
            if (isFirstDay) {
              // Premier jour : h√©bergement √† la fin uniquement
              pointsByDay.set(day, [...normalPoints, ...hebergements]);
            } else if (isLastDay) {
              // Dernier jour : h√©bergement au d√©but uniquement
              pointsByDay.set(day, [...hebergements, ...normalPoints]);
            } else {
              // Jours interm√©diaires : h√©bergement au d√©but et √† la fin
              // Garder l'ordre original (premier h√©bergement au d√©but, dernier √† la fin)
              if (hebergements.length >= 2) {
                pointsByDay.set(day, [hebergements[0], ...normalPoints, ...hebergements.slice(1)]);
              } else {
                // Si un seul h√©bergement, le placer au d√©but
                pointsByDay.set(day, [...hebergements, ...normalPoints]);
              }
            }
          }
        });
        
        return pointsByDay;
      }
      createMarker(feature, lat, lng, order) {
        const props = feature.properties || {};
        const orderStr = String(order);
        const isHebergement = (orderStr === '0.0' || orderStr === '0' || parseFloat(orderStr) === 0.0);
        
        let iconHtml, iconSize, iconAnchor, popupAnchor;
        
        if (isHebergement) {
          // Ic√¥ne d'h√©bergement
          iconHtml = '<div class="hebergement-marker">üè†</div>';
          iconSize = [40, 40];
          iconAnchor = [20, 40];
          popupAnchor = [0, -35];
        } else {
          // Ic√¥ne normale avec num√©ro
          const priorite = props.priorite || '';
          const prioInfo = prioClass(priorite);
          const cls = prioInfo.cls;
          iconHtml = '<div class="num-marker ' + cls + '">' + esc(order) + '</div>';
          iconSize = [32, 32];
          iconAnchor = [16, 32];
          popupAnchor = [0, -28];
        }
        
        const icon = L.divIcon({
          className: '',
          html: iconHtml,
          iconSize: iconSize,
          iconAnchor: iconAnchor,
          popupAnchor: popupAnchor
        });
        const marker = L.marker([lat, lng], { icon: icon });
        marker.bindPopup(makePopup(props, order), { maxWidth: 320 });
        
        // Enregistrer le marqueur pour le routage interactif si disponible
        if (typeof registerVisitMarkerForRouting === 'function') {
          registerVisitMarkerForRouting(marker, feature);
        }
        
        return marker;
      }
      createPointLayers(features) {
        this.clearPointLayers();
        const pointsByDay = this.groupPointsByDay(features);
        
        if (pointsByDay.size === 0) {

          return;
        }
        
        pointsByDay.forEach((points, day) => {
          const layerGroup = L.layerGroup();
          points.forEach((point) => {
            const feature = features[point.index];
            if (feature) {
              const marker = this.createMarker(feature, point.lat, point.lon, point.order);
              marker.addTo(layerGroup);
            }
          });
          this.pointLayers.set(day, {
            layer: layerGroup,
            day: day,
            pointCount: points.length
          });
        });
        

      }
      
      createRouteLayers(features) {
        this.clearRouteLayers();
        const pointsByDay = this.groupPointsByDay(features);
        
        if (pointsByDay.size === 0) {

          return;
        }
        
        pointsByDay.forEach((points, day) => {
          const color = this.dayColors[(day - 1) % this.dayColors.length];
          const layerGroup = L.layerGroup();
          
          for (let i = 0; i < points.length - 1; i++) {
            const point1 = points[i];
            const point2 = points[i + 1];
            const routeLine = this.createRouteLine(point1, point2, color);
            routeLine.addTo(layerGroup);
          }
          
          this.routeLayers.set(day, {
            layer: layerGroup,
            color: color,
            day: day,
            pointCount: points.length
          });
        });
        

      }
      clearPointLayers() {
        this.pointLayers.forEach((pointData, day) => {
          if (this.map.hasLayer(pointData.layer)) {
            this.map.removeLayer(pointData.layer);
          }
        });
        this.pointLayers.clear();
      }
      
      clearRouteLayers() {
        this.routeLayers.forEach((routeData, day) => {
          if (this.map.hasLayer(routeData.layer)) {
            this.map.removeLayer(routeData.layer);
          }
        });
        this.routeLayers.clear();
      }
      addLayerControl(baseLayers, overlayLayers) {
        if (this.layerControl) {
          this.map.removeControl(this.layerControl);
        }
        
        const pointOverlays = {};
        this.pointLayers.forEach((pointData, day) => {
          pointOverlays['Points - Jour ' + day] = pointData.layer;
        });
        
        const routeOverlays = {};
        this.routeLayers.forEach((routeData, day) => {
          routeOverlays['Trajets - Jour ' + day] = routeData.layer;
        });
        
        // Int√©grer le calque de routage interactif si disponible
        const interactiveOverlays = {};
        if (typeof interactiveRoutingManager !== 'undefined' && interactiveRoutingManager) {
          const interactiveLayers = interactiveRoutingManager.addLayerControl(baseLayers, overlayLayers);
          Object.assign(interactiveOverlays, interactiveLayers);
        }
        
        const allOverlays = Object.assign({}, pointOverlays, routeOverlays, interactiveOverlays, overlayLayers);
        
        this.layerControl = L.control.layers(baseLayers, allOverlays, {
          position: 'topright',
          collapsed: true
        });
        
        this.layerControl.addTo(this.map);
      }
      
      showAllPoints() {
        this.pointLayers.forEach((pointData, day) => {
          if (!this.map.hasLayer(pointData.layer)) {
            pointData.layer.addTo(this.map);
          }
        });
      }
      
      hideAllPoints() {
        this.pointLayers.forEach((pointData, day) => {
          if (this.map.hasLayer(pointData.layer)) {
            this.map.removeLayer(pointData.layer);
          }
        });
      }
      
      showAllRoutes() {
        this.routeLayers.forEach((routeData, day) => {
          if (!this.map.hasLayer(routeData.layer)) {
            routeData.layer.addTo(this.map);
          }
        });
      }
      
      hideAllRoutes() {
        this.routeLayers.forEach((routeData, day) => {
          if (this.map.hasLayer(routeData.layer)) {
            this.map.removeLayer(routeData.layer);
          }
        });
      }
    }
    let routeManager = null;
    
    function initRouteManager(map) {
      if (!routeManager) {
        routeManager = new RouteLayerManager(map);

      }
      return routeManager;
    }
    function processRoutes(features) {
      if (!routeManager) {
        if (typeof map !== 'undefined') {
          routeManager = initRouteManager(map);
        } else {

          return;
        }
      }
      
      const layersToRemove = [];
      map.eachLayer((layer) => {
        if (layer instanceof L.FeatureGroup) {
          const layers = layer.getLayers();
          const hasMarkers = layers.some(l => l instanceof L.Marker);
          if (hasMarkers) {
            layersToRemove.push(layer);
          }
        } else if (layer instanceof L.Marker) {
          layersToRemove.push(layer);
        }
      });
      
      layersToRemove.forEach((layer) => {
        map.removeLayer(layer);
      });
      

      routeManager.createPointLayers(features);
      routeManager.createRouteLayers(features);
      
      const baseLayers = {};
      const overlayLayers = {};
      routeManager.addLayerControl(baseLayers, overlayLayers);
      
      routeManager.showAllPoints();
    }    
    // ============================================================
    // FIN DU MODULE ROUTES
    // ============================================================
    
    function integrateRoutes(features) {
      if (typeof map === 'undefined') {

        setTimeout(() => integrateRoutes(features), 100);
        return;
      }
      
      if (!routeManager) {
        routeManager = initRouteManager(map);
      }
      
      processRoutes(features);
    }
    // ============================================================
    // MODULE HOP-ON HOP-OFF - Calque du bus touristique de Rome
    // ============================================================
    // Ce code est compl√®tement ind√©pendant du code principal et des routes
    // Il g√®re uniquement l'affichage du parcours et des arr√™ts du bus hop-on hop-off
        class HopOnHopOffLayerManager {
      constructor(map) {
        this.map = map;
        this.routeLayer = null;
        this.stopMarkers = [];
        this.layerControl = null;
      }
      createRoute() {
        // Coordonn√©es des arr√™ts du bus hop-on hop-off
        const routeCoordinates = [
          [41.9019, 12.5018],
          [41.8974, 12.4986],
          [41.8902, 12.4922],
          [41.886, 12.4858],
          [41.8957, 12.4822],
          [41.9022, 12.4534],
          [41.9075, 12.4835],
          [41.9036, 12.4886]
        ];
        
        // Cr√©er la polyline du parcours
        this.routeLayer = L.polyline(routeCoordinates, {
          color: '#ff6b35',
          weight: 5,
          opacity: 0.8,
          className: 'hoponhopoff-route'
        });
        
        // Ajouter un popup au parcours
        const routeInfo = '<div style="text-align: center; padding: 10px;">' +
          '<h3 style="margin: 0 0 10px 0; color: #ff6b35;">üöå Bus Hop-On Hop-Off</h3>' +
          '<p style="margin: 5px 0;"><strong>Parcours touristique de Rome</strong></p>' +
          '<p style="margin: 5px 0; font-size: 0.9em; color: #666;">' +
          '8 arr√™ts principaux</p>' +
          '<p style="margin: 5px 0; font-size: 0.85em; color: #888;">' +
          'Cliquez sur les marqueurs pour voir les arr√™ts</p>' +
          '</div>';
        this.routeLayer.bindPopup(routeInfo);
        
        return this.routeLayer;
      }
      createStops() {
        // Nettoyer les marqueurs existants
        this.clearStops();
        
        // D√©finir les arr√™ts
        const stops = [
          {
            name: "Termini Railway Station",
            lat: 41.9019,
            lon: 12.5018,
            description: "Gare principale de Rome - Via Giovanni Giolitti, 32 - Point de d√©part principal",
            order: 1,
            note: ""
          },
          {
            name: "Basilica Santa Maria Maggiore",
            lat: 41.8974,
            lon: 12.4986,
            description: "Basilique Sainte-Marie-Majeure - Piazza dell\'Esquilino, 14 - Une des quatre basiliques majeures de Rome",
            order: 2,
            note: ""
          },
          {
            name: "Colosseum",
            lat: 41.8902,
            lon: 12.4922,
            description: "Colis√©e - Via di San Gregorio (arr√™t de bus en face de l\'entr√©e du Forum Romain) - Amphith√©√¢tre Flavien",
            order: 3,
            note: ""
          },
          {
            name: "Circo Massimo",
            lat: 41.886,
            lon: 12.4858,
            description: "Cirque Maxime - Piazzale Ugo La Malfa - Ancien stade romain",
            order: 4,
            note: ""
          },
          {
            name: "Piazza Venezia",
            lat: 41.8957,
            lon: 12.4822,
            description: "Place de Venise - Via di Teatro Marcello - Place principale avec le monument √† Victor-Emmanuel II",
            order: 5,
            note: ""
          },
          {
            name: "Vatican",
            lat: 41.9022,
            lon: 12.4534,
            description: "Vatican - Lungotevere Tor di Nona, 7 - Mus√©es du Vatican et Basilique Saint-Pierre",
            order: 6,
            note: ""
          },
          {
            name: "Ludovisi / Spanish Steps",
            lat: 41.9075,
            lon: 12.4835,
            description: "Ludovisi / Spanish Steps - Via Ludovisi, 73 - Escalier de la Trinit√©-des-Monts",
            order: 7,
            note: ""
          },
          {
            name: "Piazza Barberini / Spanish Steps",
            lat: 41.9036,
            lon: 12.4886,
            description: "Piazza Barberini / Spanish Steps - Via Barberini, 12 - Place avec la fontaine du Triton",
            order: 8,
            note: ""
          }
        ];

        // Cr√©er un marqueur pour chaque arr√™t
        stops.forEach((stop) => {
          // Cr√©er une ic√¥ne personnalis√©e pour les arr√™ts (juste l'ic√¥ne de bus)
          const stopIcon = L.divIcon({
            className: 'hoponhopoff-stop-icon',
            html: '<div class="hoponhopoff-stop-marker" title="Arr√™t ' + stop.order + '"></div>',
            iconSize: [32, 32],
            iconAnchor: [16, 16],
            popupAnchor: [0, -16]
          });
          
          // Cr√©er le marqueur
          const marker = L.marker([stop.lat, stop.lon], { icon: stopIcon });
          
          // Cr√©er le contenu du popup
          const popupContent = '<div style="text-align: center; padding: 8px; min-width: 200px;">' +
            '<div style="color: #ff6b35; font-weight: bold; margin-bottom: 5px;">' +
            'üöå Arr√™t ' + stop.order + '</div>' +
            '<div style="font-size: 1.1em; font-weight: bold; margin-bottom: 5px;">' +
            stop.name + '</div>' +
            (stop.description ? '<div style="font-size: 0.9em; color: #666; margin-top: 5px;">' +
            stop.description + '</div>' : '') +
            (stop.note ? '<div style="font-size: 0.85em; color: #d97706; margin-top: 8px; padding: 5px; background-color: #fef3c7; border-left: 3px solid #d97706; border-radius: 3px;">' +
            '‚ö†Ô∏è ' + stop.note + '</div>' : '') +
            '</div>';
          
          marker.bindPopup(popupContent);
          this.stopMarkers.push(marker);
        });
        

        return this.stopMarkers;
      }
      clearRoute() {
        if (this.routeLayer && this.map.hasLayer(this.routeLayer)) {
          this.map.removeLayer(this.routeLayer);
        }
        this.routeLayer = null;
      }
      
      clearStops() {
        this.stopMarkers.forEach((marker) => {
          if (this.map.hasLayer(marker)) {
            this.map.removeLayer(marker);
          }
        });
        this.stopMarkers = [];
      }
      
      clearAll() {
        this.clearRoute();
        this.clearStops();
      }
      showRoute() {
        if (this.routeLayer && !this.map.hasLayer(this.routeLayer)) {
          this.routeLayer.addTo(this.map);
        }
      }
      
      hideRoute() {
        if (this.routeLayer && this.map.hasLayer(this.routeLayer)) {
          this.map.removeLayer(this.routeLayer);
        }
      }
      
      showStops() {
        this.stopMarkers.forEach((marker) => {
          if (!this.map.hasLayer(marker)) {
            marker.addTo(this.map);
          }
        });
      }
      
      hideStops() {
        this.stopMarkers.forEach((marker) => {
          if (this.map.hasLayer(marker)) {
            this.map.removeLayer(marker);
          }
        });
      }
      
      showAll() {
        this.showRoute();
        this.showStops();
      }
      
      hideAll() {
        this.hideRoute();
        this.hideStops();
      }
      addLayerControl(baseLayers, overlayLayers) {
        if (this.layerControl) {
          this.map.removeControl(this.layerControl);
        }
        
        // Cr√©er les calques s√©par√©s : Arr√™ts en premier, puis Parcours
        const stopsLayerGroup = L.layerGroup(this.stopMarkers);
        
        const hoponhopoffOverlays = {
          'Bus Hop-On Hop-Off - Arr√™ts': stopsLayerGroup,
          'Bus Hop-On Hop-Off - Parcours': this.routeLayer
        };
        
        const allOverlays = Object.assign({}, hoponhopoffOverlays, overlayLayers);
        
        this.layerControl = L.control.layers(baseLayers, allOverlays, {
          position: 'topright',
          collapsed: true
        });
        
        this.layerControl.addTo(this.map);
      }
    }
    let hopOnHopOffManager = null;
    
    function initHopOnHopOffManager(map) {
      if (!hopOnHopOffManager) {
        hopOnHopOffManager = new HopOnHopOffLayerManager(map);

      }
      return hopOnHopOffManager;
    }
    function processHopOnHopOff() {
      // V√©rifier que map existe avant d'essayer de l'utiliser
      if (typeof map === 'undefined') {

        return;
      }
      
      if (!hopOnHopOffManager) {
        hopOnHopOffManager = initHopOnHopOffManager(map);
      }
      
      // Cr√©er le parcours et les arr√™ts (mais ne pas les afficher par d√©faut)
      hopOnHopOffManager.createRoute();
      hopOnHopOffManager.createStops();
      
      // Ne pas afficher par d√©faut - les cases seront non coch√©es dans le contr√¥le de calques
      // L'utilisateur devra cocher les cases pour afficher les arr√™ts ou le parcours
      
      // Ajouter au contr√¥le de calques (Arr√™ts en premier, Parcours en dessous)
      const baseLayers = {};
      const overlayLayers = {};
      hopOnHopOffManager.addLayerControl(baseLayers, overlayLayers);
      

    }    
    // ============================================================
    // FIN DU MODULE HOP-ON HOP-OFF
    // ============================================================
    
    // Int√©gration du calque hop-on hop-off
    function integrateHopOnHopOff() {
      if (typeof map === 'undefined') {

        setTimeout(() => integrateHopOnHopOff(), 100);
        return;
      }
      
      if (!hopOnHopOffManager) {
        hopOnHopOffManager = initHopOnHopOffManager(map);
      }
      
      processHopOnHopOff();
    }
    // ============================================================
    // MODULE ROUTAGE INTERACTIF - Calcul d'itin√©raires entre visites
    // ============================================================
    // Ce module permet de s√©lectionner deux visites et de calculer
    // l'itin√©raire optimal selon le mode de transport
        class InteractiveRoutingManager {
      constructor(map) {
        this.map = map;
        this.startVisit = null;        // Feature GeoJSON de la visite de d√©part
        this.endVisit = null;          // Feature GeoJSON de la visite d'arriv√©e
        this.routeLayer = null;        // Calque Leaflet pour l'itin√©raire
        this.routingLayerGroup = null; // Groupe de calques pour le contr√¥leur (pour la case √† cocher)
        this.startMarker = null;       // Marqueur visuel de d√©part (vert)
        this.endMarker = null;         // Marqueur visuel d'arriv√©e (rouge)
        this.isActive = false;         // Mode interactif activ√©/d√©sactiv√©
        this.visitMarkers = new Map(); // Map<L.Marker, Feature> : marqueurs des visites
        this.infoPanel = null;         // √âl√©ment DOM du panneau d'information
        this.clickState = 0;           // 0 = attend d√©part, 1 = attend arriv√©e
        this.originalIcons = new Map(); // Map<L.Marker, L.Icon> : sauvegarde des ic√¥nes originales
        
        // Cr√©er le panneau d'information d√®s l'initialisation
        this.createInfoPanel();
      }
      // Configuration OSRM
      OSRM_PROFILES = {
        'marche': 'foot',
        'pied': 'foot',
        'velo': 'bike',
        'v√©lo': 'bike',
        'voiture': 'car',
        'taxi': 'car',
        'default': 'foot'
      };
      
      OSRM_BASE_URL = 'https://routing.openstreetmap.de/routed-{profile}';
      activate() {

        if (this.isActive) {

          return;
        }
        
        this.isActive = true;
        this.clickState = 0;

        
        // S'assurer que le panneau existe et est visible
        if (!this.infoPanel) {

          this.createInfoPanel();
        }
        if (this.infoPanel) {
          this.infoPanel.style.display = 'block';

        }
        
        // Ajouter des √©couteurs de clic sur les marqueurs existants

        this.attachClickListeners();

        
        // Mettre √† jour l'interface
        this.updateInfoPanel();
        

      }
      
      deactivate() {
        if (!this.isActive) return;
        
        this.isActive = false;
        this.clickState = 0;
        
        // Restaurer les popups originales et retirer les √©couteurs
        this.visitMarkers.forEach((feature, marker) => {
          // Retirer les √©couteurs de routage interactif
          if (marker._routingClickHandler) {
            marker.off('click', marker._routingClickHandler);
            marker._routingClickHandler = null;
          }
          if (marker._routingPopupHandler) {
            marker.off('popupopen', marker._routingPopupHandler);
            marker._routingPopupHandler = null;
          }
          // Retirer l'√©couteur DOM
          if (marker._routingDomHandler && marker._icon) {
            marker._icon.removeEventListener('click', marker._routingDomHandler, true);
            marker._routingDomHandler = null;
          }
          // Restaurer la popup originale
          if (marker._originalPopup && marker._originalPopupContent) {
            marker.bindPopup(marker._originalPopupContent);
          }
        });
        
        // Nettoyer les s√©lections
        this.clearSelection();
        
        // Masquer le panneau d'information mais garder le panneau visible pour r√©activation
        if (this.infoPanel) {
          const infoDiv = document.getElementById('routing-info');
          if (infoDiv) {
            infoDiv.style.display = 'none';
          }
        }
        

      }
      registerVisitMarker(marker, feature) {

        this.visitMarkers.set(marker, feature);

        
        // Sauvegarder l'ic√¥ne originale
        if (!this.originalIcons.has(marker)) {
          this.originalIcons.set(marker, marker.getIcon());

        }
        
        // Si le mode est actif, ajouter un √©couteur sp√©cial imm√©diatement

        if (this.isActive) {

          this.attachMarkerListener(marker);
        }
        // Note: Si le mode est activ√© plus tard, attachClickListeners() sera appel√©
        // et attachera les √©couteurs √† tous les marqueurs enregistr√©s
        

      }
      
      attachMarkerListener(marker) {

        // Sauvegarder la popup originale si elle existe
        if (!marker._originalPopup) {
          const popup = marker.getPopup();

          if (popup) {
            marker._originalPopup = popup;
            marker._originalPopupContent = popup.getContent();
          }
        }
        
        // Retirer les anciens √©couteurs pour √©viter les doublons
        if (marker._routingClickHandler) {

          marker.off('click', marker._routingClickHandler);
        }
        if (marker._routingPopupHandler) {

          marker.off('popupopen', marker._routingPopupHandler);
        }
        
        // D√âSACTIVER LA POPUP EN MODE INTERACTIF
        // On doit unbind la popup pour que notre handler re√ßoive les clics
        if (marker._originalPopup) {
          marker.unbindPopup();

        }
        
        // Cr√©er un √©couteur qui intercepte le clic en mode interactif
        const self = this;
        const clickHandler = function(e) {

          if (self.isActive) {

            // Emp√™cher compl√®tement l'√©v√©nement de se propager
            L.DomEvent.stopPropagation(e);
            L.DomEvent.preventDefault(e);

            
            // Dans Leaflet, 'this' dans le handler fait r√©f√©rence au marqueur
            const clickedMarker = this;

            
            const feature = self.visitMarkers.get(clickedMarker);
            if (feature) {


              self.selectVisit(feature, clickedMarker);
            } else {


            }
            return false;
          } else {

          }
        };
        
        // Cr√©er un √©couteur pour emp√™cher l'ouverture de la popup (au cas o√π)
        const popupHandler = function(e) {

          if (self.isActive) {

            L.DomEvent.stop(e);
            this.closePopup();
            return false;
          }
        };
        
        // Attacher l'√©couteur Leaflet AVANT que la popup ne soit g√©r√©e
        // Utiliser once: false pour que l'√©couteur reste actif
        marker.on('click', clickHandler);
        marker.on('popupopen', popupHandler);

        
        // Stocker les handlers pour pouvoir les retirer plus tard
        marker._routingClickHandler = clickHandler;
        marker._routingPopupHandler = popupHandler;
      }
      
      attachClickListeners() {


        
        let count = 0;
        this.visitMarkers.forEach((feature, marker) => {
          count++;

          // Attacher l'√©couteur m√™me si le marqueur est dans un calque de route
          this.attachMarkerListener(marker);
        });
        

      }
      
      // M√©thode publique pour r√©attacher les √©couteurs (utile apr√®s cr√©ation de nouveaux marqueurs)
      refreshListeners() {
        if (this.isActive) {
          this.attachClickListeners();
        }
      }
      selectVisit(feature, marker) {

        if (this.clickState === 0) {
          // S√©lectionner le d√©part

          // IMPORTANT : Sauvegarder l'ancien marqueur AVANT de le remplacer
          // pour pouvoir le r√©initialiser correctement
          const previousStartMarker = this.startMarker;
          
          this.startVisit = feature;
          this.startMarker = marker;
          this.clickState = 1;

          // Mettre √† jour le style (cela r√©initialisera l'ancien marqueur si n√©cessaire)
          this.updateMarkerStyle(marker, 'start', previousStartMarker);

        } else {
          // S√©lectionner l'arriv√©e

          // IMPORTANT : Sauvegarder l'ancien marqueur AVANT de le remplacer
          const previousEndMarker = this.endMarker;
          
          this.endVisit = feature;
          this.endMarker = marker;
          this.clickState = 0;

          // Mettre √† jour le style (cela r√©initialisera l'ancien marqueur si n√©cessaire)
          this.updateMarkerStyle(marker, 'end', previousEndMarker);

          
          // Calculer automatiquement l'itin√©raire

          // Ne PAS appeler updateInfoPanel ici car calculateRoute() le fera apr√®s le calcul
          // Cela √©vite les duplications de transport
          this.calculateRoute();
          return;
        }
        

        // Mettre √† jour le panneau uniquement avec les noms
        // IMPORTANT : Ne pas mettre √† jour le transport ici pour √©viter les duplications
        // Le transport sera mis √† jour par calculateRoute() apr√®s le calcul de l'itin√©raire
        // ou restera √† "‚Äî" si aucune route n'est calcul√©e
        const startName = this.startVisit ? this.startVisit.properties.name : '‚Äî';
        const endName = this.endVisit ? this.endVisit.properties.name : '‚Äî';
        const startNameEl = document.getElementById('routing-start-name');
        const endNameEl = document.getElementById('routing-end-name');
        if (startNameEl) startNameEl.textContent = startName;
        if (endNameEl) endNameEl.textContent = endName;

      }
      
            updateMarkerStyle(marker, type, previousMarker = null) {
        // Retirer les styles pr√©c√©dents
        if (type === 'start') {
          // S√©lection du d√©part : r√©initialiser le d√©part pr√©c√©dent ET l'arriv√©e pr√©c√©dente (si elles existent)
          // Utiliser previousMarker si fourni (plus fiable que this.startMarker qui a d√©j√† √©t√© mis √† jour)
          const oldStartMarker = previousMarker !== null ? previousMarker : (this.startMarker && this.startMarker !== marker ? this.startMarker : null);
          if (oldStartMarker) {
            this.resetMarkerStyle(oldStartMarker);
          }
          // R√©initialiser aussi l'arriv√©e si elle existe et est diff√©rente
          if (this.endMarker && this.endMarker !== marker) {
            this.resetMarkerStyle(this.endMarker);
          }
        } else {
          // S√©lection de l'arriv√©e : r√©initialiser uniquement l'arriv√©e pr√©c√©dente (si elle existe)
          // Utiliser previousMarker si fourni (plus fiable que this.endMarker qui a d√©j√† √©t√© mis √† jour)
          const oldEndMarker = previousMarker !== null ? previousMarker : (this.endMarker && this.endMarker !== marker ? this.endMarker : null);
          if (oldEndMarker) {
            this.resetMarkerStyle(oldEndMarker);
          }
          // Le marqueur de d√©part reste visible avec son style "D" vert - NE PAS le r√©initialiser
        }
        
        // Appliquer le nouveau style
        const color = type === 'start' ? '#22c55e' : '#ef4444'; // Vert ou Rouge
        const label = type === 'start' ? 'D' : 'A';
        
        // Cr√©er une nouvelle ic√¥ne avec le style de s√©lection
        const newIcon = L.divIcon({
          className: 'routing-selected-marker',
          html: `<div style="
            width: 40px; 
            height: 40px; 
            border-radius: 50%; 
            background: ${color}; 
            border: 3px solid white; 
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 18px;
          ">${label}</div>`,
          iconSize: [40, 40],
          iconAnchor: [20, 40]
        });
        
        marker.setIcon(newIcon);
      }
      
      resetMarkerStyle(marker) {
        // Restaurer l'ic√¥ne originale
        const originalIcon = this.originalIcons.get(marker);
        if (originalIcon) {
          marker.setIcon(originalIcon);
        }
      }
      
      clearSelection() {
        this.startVisit = null;
        this.endVisit = null;
        this.startMarker = null;
        this.endMarker = null;
        this.clickState = 0;

        // Retirer l'itin√©raire de la carte
        if (this.routeLayer) {
          this.map.removeLayer(this.routeLayer);
          this.routeLayer = null;
        }

        // R√©initialiser les styles des marqueurs
        this.visitMarkers.forEach((feature, marker) => {
          this.resetMarkerStyle(marker);
        });
      }
      async calculateRoute() {
        if (!this.startVisit || !this.endVisit) {

          return;
        }

        // Afficher un indicateur de chargement
        this.showLoading(true);

        try {
          // R√©cup√©rer les coordonn√©es
          const startCoords = this.startVisit.geometry.coordinates;
          const endCoords = this.endVisit.geometry.coordinates;
          const [startLng, startLat] = startCoords;
          const [endLng, endLat] = endCoords;

          // D√©terminer le profil OSRM selon le mode de transport
          // Utiliser le transport de la visite d'arriv√©e, sinon celui du d√©part, sinon 'marche' par d√©faut
          let transport = this.endVisit.properties.transport || this.startVisit.properties.transport || 'marche';
          transport = transport.trim();
          if (!transport) transport = 'marche';
          const profile = this.getOSRMProfile(transport);

          // Construire l'URL OSRM
          const baseUrl = this.OSRM_BASE_URL.replace('{profile}', profile);
          const url = `${baseUrl}/route/v1/${profile}/${startLng},${startLat};${endLng},${endLat}?overview=full&geometries=geojson&steps=false`;



          // Appeler l'API OSRM
          const response = await fetch(url, { cache: 'no-store' });
          
          if (!response.ok) {
            throw new Error(`Service OSRM indisponible (${response.status})`);
          }

          const data = await response.json();

          if (!data.routes || data.routes.length === 0) {
            throw new Error('Aucun itin√©raire trouv√©');
          }

          // Extraire les informations
          const route = data.routes[0];
          const distance = route.distance;      // en m√®tres
          const duration = route.duration;      // en secondes
          const geometry = route.geometry;      // GeoJSON LineString

          // Afficher l'itin√©raire sur la carte
          this.displayRoute(geometry, distance, duration, transport);

          // Mettre √† jour le panneau d'information avec le transport
          this.updateInfoPanel(distance, duration, transport);

        } catch (error) {

          this.showError('Impossible de calculer l\'itin√©raire : ' + error.message);
          this.showLoading(false);
        }
      }
      
      getOSRMProfile(transport) {
        const transportLower = (transport || '').toLowerCase().trim();
        return this.OSRM_PROFILES[transportLower] || this.OSRM_PROFILES['default'];
      }
      
      displayRoute(geometry, distance, duration, transport) {
        // Retirer l'ancien itin√©raire si pr√©sent
        if (this.routeLayer) {
          this.map.removeLayer(this.routeLayer);
          // Retirer aussi du groupe de calques si il existe
          if (this.routingLayerGroup) {
            this.routingLayerGroup.removeLayer(this.routeLayer);
          }
        }

        // Cr√©er un nouveau calque GeoJSON
        this.routeLayer = L.geoJSON(geometry, {
          style: {
            color: '#2563eb',      // Bleu pour diff√©rencier des trajets automatiques
            weight: 5,
            opacity: 0.8,
            className: 'interactive-route-line'
          }
        });

        // Cr√©er le contenu de la popup
        const popupContent = this.createRoutePopup(distance, duration, transport);
        this.routeLayer.bindPopup(popupContent);

        // Ajouter au groupe de calques si il existe (pour que la case √† cocher fonctionne)
        if (this.routingLayerGroup) {
          this.routingLayerGroup.addLayer(this.routeLayer);
          // Ajouter le groupe √† la carte si ce n'est pas d√©j√† fait
          if (!this.map.hasLayer(this.routingLayerGroup)) {
            this.routingLayerGroup.addTo(this.map);
          }
        } else {
          // Sinon, ajouter directement √† la carte (comportement par d√©faut)
          this.routeLayer.addTo(this.map);
        }

        // Ajuster la vue pour voir l'itin√©raire complet
        const bounds = this.routeLayer.getBounds();
        if (bounds.isValid()) {
          this.map.fitBounds(bounds.pad(0.1));
        }
      }
      
      createRoutePopup(distance, duration, transport) {
        const distanceText = this.formatDistance(distance);
        const durationText = this.formatDuration(duration);
        const transportText = transport ? transport.charAt(0).toUpperCase() + transport.slice(1) : 'Marche';

        return `
          <div style="text-align: center; padding: 10px; min-width: 200px;">
            <h3 style="margin: 0 0 10px 0; font-size: 16px;">Itin√©raire calcul√©</h3>
            <hr style="margin: 8px 0; border: none; border-top: 1px solid #ddd;">
            <div style="margin: 5px 0;">
              <strong>Distance :</strong> ${distanceText}
            </div>
            <div style="margin: 5px 0;">
              <strong>Temps :</strong> ${durationText}
            </div>
            <div style="margin: 5px 0;">
              <strong>Transport :</strong> ${transportText}
            </div>
          </div>
        `;
      }
      
      formatDistance(meters) {
        if (meters < 1000) {
          return Math.round(meters) + " m";
        }
        return (meters / 1000).toFixed(2) + " km";
      }
      
      formatDuration(seconds) {
        const minutes = Math.round(seconds / 60);
        if (minutes < 60) {
          return minutes + " min";
        }
        const hours = Math.floor(minutes / 60);
        const remainingMinutes = minutes % 60;
        return `${hours} h ${remainingMinutes.toString().padStart(2, '0')} min`;
      }

      createInfoPanel() {
        // V√©rifier si le panneau existe d√©j√†
        let panel = document.getElementById('routing-interactive-panel');
        if (panel) {
          this.infoPanel = panel;
          panel.style.display = 'block';
          return;
        }

        // Cr√©er le panneau
        panel = document.createElement('div');
        panel.id = 'routing-interactive-panel';
        panel.className = 'routing-interactive-panel';
        panel.innerHTML = `
          <div style="font-weight: bold; margin-bottom: 10px; font-size: 16px;">
            üó∫Ô∏è Routage interactif
          </div>
          <div style="margin-bottom: 10px; font-size: 12px; color: #666; padding: 8px; background: #f5f5f5; border-radius: 4px;">
            <strong>Mode normal :</strong> Cliquez sur les marqueurs pour voir les informations.<br>
            <strong>Mode interactif :</strong> Cliquez sur les marqueurs pour s√©lectionner d√©part/arriv√©e.
          </div>
          <div style="margin-bottom: 10px;">
            <button id="routing-activate-btn" class="routing-btn">Activer</button>
            <button id="routing-deactivate-btn" class="routing-btn" style="display: none;">D√©sactiver</button>
          </div>
          <div id="routing-info" style="display: none;">
            <div style="margin: 5px 0;">
              <strong>D√©part :</strong> <span id="routing-start-name">‚Äî</span>
            </div>
            <div style="margin: 5px 0;">
              <strong>Arriv√©e :</strong> <span id="routing-end-name">‚Äî</span>
            </div>
            <hr style="margin: 8px 0; border: none; border-top: 1px solid #ddd;">
            <div style="margin: 5px 0;">
              <strong>Distance :</strong> <span id="routing-distance">‚Äî</span>
            </div>
            <div style="margin: 5px 0;">
              <strong>Temps :</strong> <span id="routing-time">‚Äî</span>
            </div>
            <div style="margin: 5px 0;">
              <strong>Transport :</strong> <span id="routing-transport" style="display: inline;">‚Äî</span>
            </div>
            <div style="margin-top: 10px;">
              <button id="routing-calculate-btn" class="routing-btn">Calculer</button>
              <button id="routing-swap-btn" class="routing-btn">Inverser</button>
              <button id="routing-reset-btn" class="routing-btn">R√©initialiser</button>
            </div>
          </div>
        `;

        // Ajouter au DOM
        document.body.appendChild(panel);
        this.infoPanel = panel;

        // Ajouter les √©couteurs de boutons
        const self = this;
        document.getElementById('routing-activate-btn').addEventListener('click', function() {
          self.activate();
          document.getElementById('routing-activate-btn').style.display = 'none';
          document.getElementById('routing-deactivate-btn').style.display = 'inline-block';
          document.getElementById('routing-info').style.display = 'block';
          panel.classList.add('active');
        });

        document.getElementById('routing-deactivate-btn').addEventListener('click', function() {
          self.deactivate();
          document.getElementById('routing-activate-btn').style.display = 'inline-block';
          document.getElementById('routing-deactivate-btn').style.display = 'none';
          const infoDiv = document.getElementById('routing-info');
          if (infoDiv) {
            infoDiv.style.display = 'none';
          }
          panel.classList.remove('active');
        });

        document.getElementById('routing-calculate-btn').addEventListener('click', function() {
          if (self.startVisit && self.endVisit) {
            self.calculateRoute();
          }
        });

        document.getElementById('routing-swap-btn').addEventListener('click', function() {
          self.swapVisits();
        });

        document.getElementById('routing-reset-btn').addEventListener('click', function() {
          self.reset();
        });
      }
      
      updateInfoPanel(distance = null, duration = null, transport = null) {
        if (!this.infoPanel) return;

        const startName = this.startVisit ? this.startVisit.properties.name : '‚Äî';
        const endName = this.endVisit ? this.endVisit.properties.name : '‚Äî';

        const startNameEl = document.getElementById('routing-start-name');
        const endNameEl = document.getElementById('routing-end-name');
        const distanceEl = document.getElementById('routing-distance');
        const timeEl = document.getElementById('routing-time');
        const transportEl = document.getElementById('routing-transport');
        
        if (startNameEl) startNameEl.textContent = startName;
        if (endNameEl) endNameEl.textContent = endName;

        if (distance !== null && duration !== null && distanceEl && timeEl) {
          distanceEl.textContent = this.formatDistance(distance);
          timeEl.textContent = this.formatDuration(duration);
        } else {
          if (distanceEl) distanceEl.textContent = '‚Äî';
          if (timeEl) timeEl.textContent = '‚Äî';
        }
        
        // Afficher le mode de transport
        // IMPORTANT : Toujours r√©initialiser compl√®tement pour √©viter les duplications
        if (transportEl) {
          // Vider COMPL√àTEMENT le contenu AVANT de d√©terminer le nouveau texte
          // Cela √©vite toute concat√©nation r√©siduelle
          transportEl.textContent = '';
          
          let transportText = '‚Äî';
          
          // Priorit√© 1 : Transport fourni explicitement en param√®tre (depuis calculateRoute)
          // C'est le cas le plus fr√©quent apr√®s le calcul d'un itin√©raire
          if (transport !== null && transport !== undefined && transport !== '') {
            const transportStr = String(transport).trim();
            if (transportStr) {
              transportText = transportStr.charAt(0).toUpperCase() + transportStr.slice(1).toLowerCase();
            }
          } 
          // Priorit√© 2 : D√©terminer depuis les visites (uniquement si aucun transport fourni)
          // Utilis√© uniquement quand on s√©lectionne d√©part/arriv√©e sans calculer de route
          else if (this.startVisit || this.endVisit) {
            // Priorit√© : transport de l'arriv√©e, puis transport du d√©part, puis 'Marche' par d√©faut
            const transportFromEnd = this.endVisit ? (this.endVisit.properties.transport || '').trim() : '';
            const transportFromStart = this.startVisit ? (this.startVisit.properties.transport || '').trim() : '';
            const finalTransport = transportFromEnd || transportFromStart || 'Marche';
            if (finalTransport) {
              transportText = finalTransport.charAt(0).toUpperCase() + finalTransport.slice(1).toLowerCase();
            }
          }
          
          // IMPORTANT : Utiliser textContent pour remplacer COMPL√àTEMENT le contenu pr√©c√©dent
          // Le contenu a d√©j√† √©t√© vid√© ci-dessus, donc cette assignation remplace tout
          transportEl.textContent = transportText;
        }
      }
      
      showLoading(show) {
        const timeEl = document.getElementById('routing-time');
        if (timeEl) {
          if (show) {
            timeEl.textContent = 'Calcul en cours...';
          }
          // Ne pas r√©initialiser √† "‚Äî" si show est false, car updateInfoPanel va le mettre √† jour
        }
      }
      
      showError(message) {{
        alert(message);
{self._debug_error('message')}
      }}
      swapVisits() {
        const tmp = this.startVisit;
        this.startVisit = this.endVisit;
        this.endVisit = tmp;

        const tmpMarker = this.startMarker;
        this.startMarker = this.endMarker;
        this.endMarker = tmpMarker;

        // Recalculer l'itin√©raire
        if (this.startVisit && this.endVisit) {
          this.calculateRoute();
        } else {
          this.updateInfoPanel();
        }
      }
      
      reset() {
        this.clearSelection();
        this.updateInfoPanel();
      }
      
      clearSelection() {
        // Utiliser la m√©thode du MarkerManager
        // Note: clearSelection est maintenant dans MarkerManagerGenerator
        this.startVisit = null;
        this.endVisit = null;
        this.startMarker = null;
        this.endMarker = null;
        this.clickState = 0;

        // Retirer l'itin√©raire de la carte
        if (this.routeLayer) {
          this.map.removeLayer(this.routeLayer);
          this.routeLayer = null;
        }

        // R√©initialiser les styles des marqueurs
        this.visitMarkers.forEach((feature, marker) => {
          this.resetMarkerStyle(marker);
        });
      }
      
      addLayerControl(baseLayers, overlayLayers) {
        // Cette m√©thode sera appel√©e par RouteLayerManager pour int√©grer le calque
        // dans le contr√¥leur de calques Leaflet.
        // 
        // IMPORTANT : La case √† cocher "Routage interactif" dans le contr√¥leur de calques
        // contr√¥le UNIQUEMENT la visibilit√© de l'itin√©raire calcul√© (la ligne bleue sur la carte).
        // Elle ne contr√¥le PAS :
        // - Le panneau de routage interactif (qui reste toujours visible)
        // - Le mode interactif (activ√©/d√©sactiv√© via le bouton "Activer" dans le panneau)
        //
        // Utilit√© : Permet de masquer/afficher temporairement l'itin√©raire calcul√©
        // sans avoir √† le supprimer ou recalculer.
        const interactiveOverlays = {};
        
        // Cr√©er un groupe de calques qui contient l'itin√©raire
        const routingLayerGroup = L.layerGroup();
        
        // Ajouter l'itin√©raire au groupe s'il existe d√©j√†
        if (this.routeLayer) {
          routingLayerGroup.addLayer(this.routeLayer);
        }
        
        // Stocker une r√©f√©rence au groupe pour pouvoir y ajouter l'itin√©raire plus tard
        this.routingLayerGroup = routingLayerGroup;
        
        interactiveOverlays['Routage interactif'] = routingLayerGroup;
        
        return interactiveOverlays;
      }
    }
    
    // ============================================================
    // FIN DU MODULE ROUTAGE INTERACTIF
    // ============================================================
    
    let interactiveRoutingManager = null;
    
    function initInteractiveRouting(map) {
      if (!interactiveRoutingManager) {
        interactiveRoutingManager = new InteractiveRoutingManager(map);

      }
      return interactiveRoutingManager;
    }
    
    function integrateInteractiveRouting(features) {
      if (typeof map === 'undefined') {

        setTimeout(() => integrateInteractiveRouting(features), 100);
        return;
      }
      
      if (!interactiveRoutingManager) {
        interactiveRoutingManager = initInteractiveRouting(map);
        // Le panneau est cr√©√© automatiquement dans le constructeur
        // S'assurer qu'il est visible
        if (interactiveRoutingManager.infoPanel) {
          interactiveRoutingManager.infoPanel.style.display = 'block';
        }
      }
      
      // Enregistrer les marqueurs de visites apr√®s leur cr√©ation
      // Cette fonction sera appel√©e depuis processGeoJSON apr√®s la cr√©ation des marqueurs
      // Note: Il faut que les marqueurs soient cr√©√©s avant d'appeler cette fonction

    }
    
    // Fonction helper pour enregistrer un marqueur de visite
    function registerVisitMarkerForRouting(marker, feature) {
      // Initialiser automatiquement le gestionnaire s'il n'existe pas encore
      if (!interactiveRoutingManager && typeof map !== 'undefined') {
        interactiveRoutingManager = initInteractiveRouting(map);
      }
      if (interactiveRoutingManager) {
        interactiveRoutingManager.registerVisitMarker(marker, feature);
        // Si le mode interactif est d√©j√† actif, attacher imm√©diatement l'√©couteur
        if (interactiveRoutingManager.isActive) {
          interactiveRoutingManager.attachMarkerListener(marker);
        }
      }
    }

    // ‚úÖ URL du fichier GeoJSON sur GitHub
    const GEOJSON_URL = "https://raw.githubusercontent.com/Sinnamary/Rome/main/attractions_rome_2026-01-09.geojson";

    // D√©clarer map dans le scope global pour √©viter les erreurs de r√©f√©rence
    let map;
    
    // Initialiser la carte
    map = L.map('map', { zoomControl: true });

    // Fond de carte (OpenStreetMap)
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    function esc(s){
      return String(s ?? '').replace(/[&<>"']/g, (c)=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c]));
    }

    function prioClass(prio){
      const p = String(prio ?? '').toLowerCase().trim();
      if (p === 'haute') return { cls: 'prio-haute', badge: 'badge-haute' };
      if (p === 'moyenne') return { cls: 'prio-moyenne', badge: 'badge-moyenne' };
      if (p === 'basse') return { cls: 'prio-basse', badge: 'badge-basse' };
      return { cls: 'prio-defaut', badge: 'badge-defaut' };
    }

    function formatReservation(v){
      if (v === true || String(v).toLowerCase() === 'true') return 'Oui';
      if (v === false || String(v).toLowerCase() === 'false') return 'Non';
      return esc(v);
    }

    function formatDateFrench(dateStr){
      if (!dateStr) return '';
      // Convertir YYYY-MM-DD en DD/MM/YYYY
      const parts = dateStr.split('-');
      if (parts.length === 3) {
        return parts[2] + '/' + parts[1] + '/' + parts[0];
      }
      return dateStr;
    }

    function formatDateFullFrench(dateStr, jourStr){
      if (!dateStr) return '';
      
      const joursSemaine = ['Dimanche', 'Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi'];
      const mois = ['janvier', 'f√©vrier', 'mars', 'avril', 'mai', 'juin', 'juillet', 'ao√ªt', 'septembre', 'octobre', 'novembre', 'd√©cembre'];
      
      try {
        const parts = dateStr.split('-');
        if (parts.length === 3) {
          const year = parseInt(parts[0], 10);
          const month = parseInt(parts[1], 10) - 1; // 0-indexed
          const day = parseInt(parts[2], 10);
          
          const date = new Date(year, month, day);
          const jourIndex = date.getDay();
          const jourNom = joursSemaine[jourIndex];
          const moisNom = mois[month];
          
          return jourNom + ' ' + day + ' ' + moisNom + ' ' + year;
        }
      } catch (e) {
        // En cas d'erreur, utiliser le format simple
        if (jourStr) {
          const parts = dateStr.split('-');
          if (parts.length === 3) {
            const mois = ['janvier', 'f√©vrier', 'mars', 'avril', 'mai', 'juin', 'juillet', 'ao√ªt', 'septembre', 'octobre', 'novembre', 'd√©cembre'];
            const month = parseInt(parts[1], 10) - 1;
            return jourStr + ' ' + parts[2] + ' ' + mois[month] + ' ' + parts[0];
          }
        }
      }
      return dateStr;
    }

    function formatDureeMinutes(dureeStr){
      if (!dureeStr) return '';
      
      try {
        // Format attendu : "H:MM" ou "HH:MM" (ex: "0:45", "2:00", "1:30")
        const parts = String(dureeStr).split(':');
        if (parts.length >= 2) {
          const hours = parseInt(parts[0], 10) || 0;
          const minutes = parseInt(parts[1], 10) || 0;
          const totalMinutes = hours * 60 + minutes;
          
          if (totalMinutes === 0) return '';
          if (totalMinutes === 1) return '1 minute';
          return totalMinutes + ' minutes';
        }
      } catch (e) {
        // En cas d'erreur, retourner la valeur originale
      }
      return dureeStr;
    }

    function makePopup(props, num){
      const name = props.name ?? `Visite ${num}`;
      const date = props.date ?? '';
      const jour = props.jour ?? '';
      const debut = props.heure_debut ?? '';
      const fin = props.heure_fin ?? '';
      const duree = props.duree ?? '';
      const prix = (props.prix ?? props.price ?? '');
      const reservation = formatReservation(props.reservation);
      const url = props.url ?? '';
      const description = props.description ?? '';
      const commentaire = props.commentaire ?? '';
      const priorite = props.priorite ?? '';

      const { badge } = prioClass(priorite);

      // Capitaliser la premi√®re lettre pour l'affichage
      const prioriteDisplay = priorite 
        ? priorite.charAt(0).toUpperCase() + priorite.slice(1).toLowerCase()
        : '';

      const badgeHtml = priorite
        ? ` <span class="badge ${badge}">${esc(prioriteDisplay)}</span>`
        : '';

      const horaire = (debut || fin) ? `${esc(debut)}${(debut && fin) ? ' ‚Äì ' : ''}${esc(fin)}` : '';

      const lienUrl = url
        ? `<li>üîó <strong>Lien</strong> : <a href="${esc(url)}" target="_blank" rel="noopener">ouvrir</a></li>`
        : '';

      const commentaireHtml = commentaire
        ? `<li>üí¨ <strong>Commentaire</strong> : ${esc(commentaire)}</li>`
        : '';

      const prixTxt = (prix === 0 || prix === "0") ? "0 ‚Ç¨" : (prix ? `${esc(prix)} ‚Ç¨` : '');

      // Formater la date en format fran√ßais DD/MM/YYYY
      const dateFormatted = formatDateFrench(date);

      // Formater la dur√©e en minutes
      const dureeFormatted = formatDureeMinutes(duree);

      // G√©n√©rer la description "Visite pr√©vue le..." en format fran√ßais complet
      let visitePrevue = '';
      if (date) {
        const dateFullFrench = formatDateFullFrench(date, jour);
        if (dateFullFrench) {
          visitePrevue = 'Visite pr√©vue le ' + dateFullFrench;
          if (horaire) {
            visitePrevue += ' de ' + horaire;
          }
        }
      }

      return `
        <div class="popup">
          <h3>${esc(num)}. ${esc(name)}${badgeHtml}</h3>
          <ul class="meta">
            ${dateFormatted ? `<li>üìÖ <strong>Date</strong> : ${esc(dateFormatted)}</li>` : ''}
            ${horaire ? `<li>‚è∞ <strong>Horaire</strong> : ${esc(horaire)}</li>` : ''}
            ${dureeFormatted ? `<li>‚è± <strong>Dur√©e</strong> : ${esc(dureeFormatted)}</li>` : ''}
            ${prixTxt ? `<li>üí∂ <strong>Prix</strong> : ${prixTxt}</li>` : ''}
            ${(props.reservation !== undefined && props.reservation !== null) ? `<li>üìû <strong>R√©servation</strong> : ${esc(reservation)}</li>` : ''}
            ${lienUrl}
            ${commentaireHtml}
          </ul>
          ${visitePrevue ? `<p class="muted" style="margin:8px 0 0 0;">${esc(visitePrevue)}</p>` : (description ? `<p class="muted" style="margin:8px 0 0 0;">${esc(description)}</p>` : '')}
        </div>
      `;
    }

    async function loadGeoJson(){
      const res = await fetch(GEOJSON_URL, { cache: 'no-store' });
      if (!res.ok) throw new Error(`Impossible de charger le GeoJSON (${res.status})`);
      const gj = await res.json();
      processGeoJSON(gj);
    function integrateRoutes(features) {
      if (typeof map === 'undefined') {

        setTimeout(() => integrateRoutes(features), 100);
        return;
      }
      
      if (!routeManager) {
        routeManager = initRouteManager(map);
      }
      
      processRoutes(features);
    }
      // Int√©grer les routes apr√®s traitement du GeoJSON
      if (typeof integrateRoutes === 'function') {
        integrateRoutes(gj.features || []);
      }
      // Int√©grer le calque hop-on hop-off apr√®s traitement du GeoJSON
      if (typeof integrateHopOnHopOff === 'function') {
        integrateHopOnHopOff();
      }    let interactiveRoutingManager = null;
    
    function initInteractiveRouting(map) {
      if (!interactiveRoutingManager) {
        interactiveRoutingManager = new InteractiveRoutingManager(map);

      }
      return interactiveRoutingManager;
    }
    
    function integrateInteractiveRouting(features) {
      if (typeof map === 'undefined') {

        setTimeout(() => integrateInteractiveRouting(features), 100);
        return;
      }
      
      if (!interactiveRoutingManager) {
        interactiveRoutingManager = initInteractiveRouting(map);
        // Le panneau est cr√©√© automatiquement dans le constructeur
        // S'assurer qu'il est visible
        if (interactiveRoutingManager.infoPanel) {
          interactiveRoutingManager.infoPanel.style.display = 'block';
        }
      }
      
      // Enregistrer les marqueurs de visites apr√®s leur cr√©ation
      // Cette fonction sera appel√©e depuis processGeoJSON apr√®s la cr√©ation des marqueurs
      // Note: Il faut que les marqueurs soient cr√©√©s avant d'appeler cette fonction

    }
    
    // Fonction helper pour enregistrer un marqueur de visite
    function registerVisitMarkerForRouting(marker, feature) {
      // Initialiser automatiquement le gestionnaire s'il n'existe pas encore
      if (!interactiveRoutingManager && typeof map !== 'undefined') {
        interactiveRoutingManager = initInteractiveRouting(map);
      }
      if (interactiveRoutingManager) {
        interactiveRoutingManager.registerVisitMarker(marker, feature);
        // Si le mode interactif est d√©j√† actif, attacher imm√©diatement l'√©couteur
        if (interactiveRoutingManager.isActive) {
          interactiveRoutingManager.attachMarkerListener(marker);
        }
      }
    }
      // Int√©grer le routage interactif apr√®s traitement du GeoJSON
      if (typeof integrateInteractiveRouting === 'function') {
        integrateInteractiveRouting(gj.features || []);
      }
    }
    
    function processGeoJSON(gj) {
      // Num√©rotation: si props.ordre / props.numero / props.visite existent => on les utilise, sinon index + 1
      const features = (gj.features ?? []).map((f, i) => {
        const p = f.properties ?? {};
        // Convertir en cha√Æne pour garantir la coh√©rence
        const num = String(p.ordre ?? p.numero ?? p.visite ?? p.id ?? (i + 1));
        return { f, num, i };
      });

      // S√©parer les points d'h√©bergement (ordre 0.0) des autres points
      const hebergementFeatures = [];
      const normalFeatures = [];
      
      features.forEach(function(item) {
        const num = item.num;
        // D√©tecter l'ordre 0.0 (h√©bergement)
        if (num === '0.0' || num === '0' || parseFloat(num) === 0.0) {
          hebergementFeatures.push(item);
        } else {
          normalFeatures.push(item);
        }
      });

      // Fonction pour calculer la distance entre deux points (degr√©s)
      function distanceDegrees(lat1, lng1, lat2, lng2) {
        const dLat = lat2 - lat1;
        const dLng = lng2 - lng1;
        return Math.sqrt(dLat * dLat + dLng * dLng);
      }
      
      // Fonction pour obtenir le score de priorit√© d'un point (plus √©lev√© = plus prioritaire)
      function getPriorityScore(props) {
        const priorite = String(props.priorite || '').toLowerCase().trim();
        let score = 0;
        // Priorit√© : haute=3, moyenne=2, basse=1, d√©faut=0
        if (priorite === 'haute') score = 3;
        else if (priorite === 'moyenne') score = 2;
        else if (priorite === 'basse') score = 1;
        // Pr√©sence d'URL : +1
        const url = props.url;
        if (url !== null && url !== undefined && String(url).trim() !== '') {
          score += 1;
        }
        return score;
      }
      
      // D√©tecter et g√©rer les points proches pour les points normaux
      const proximityThreshold = 0.0005;
      const preferPriority = true;
      const DEBUG_MODE = false; // Logs DEBUG uniquement en version locale
      
      // Pr√©parer les donn√©es avec coordonn√©es
      const featuresWithCoords = normalFeatures.map(function(item) {
        const f = item.f;
        const num = item.num;
        const i = item.i;
        const coords = f.geometry && f.geometry.type === 'Point' ? f.geometry.coordinates : null;
        if (!coords) return { f: f, num: num, i: i, lat: null, lng: null, props: {}, isPreferred: false };
        const lng = coords[0];
        const lat = coords[1];
        const props = f.properties || {};
        return { f: f, num: num, i: i, lat: lat, lng: lng, originalLat: lat, originalLng: lng, props: props, isPreferred: false };
      }).filter(function(item) { return item.lat !== null && item.lng !== null; });
      
      // Grouper les points par proximit√©
      const processedFeatures = [];
      const processedIndices = new Set();
      
      for (let i = 0; i < featuresWithCoords.length; i++) {
        if (processedIndices.has(i)) continue;
        
        const current = featuresWithCoords[i];
        const closePoints = [current];
        
        // Trouver tous les points proches de celui-ci
        for (let j = i + 1; j < featuresWithCoords.length; j++) {
          if (processedIndices.has(j)) continue;
          
          const other = featuresWithCoords[j];
          const dist = distanceDegrees(current.lat, current.lng, other.lat, other.lng);
          
          if (dist <= proximityThreshold) {
            closePoints.push(other);
          }
        }
        
        // Si un seul point, pas de d√©calage n√©cessaire
        if (closePoints.length === 1) {
          current.isPreferred = false; // Point isol√©, pas de priorisation n√©cessaire
          processedFeatures.push(current);
          processedIndices.add(current.i);
        } else {
          // Plusieurs points proches : d√©terminer lequel privil√©gier
          if (DEBUG_MODE) {
            console.log(`[DEBUG] Groupe de ${closePoints.length} points proches d√©tect√© (distance < ${proximityThreshold}) : ${closePoints.map(p => p.num).join(', ')}`);
          }
          let preferredIndex = 0;
          
          if (preferPriority) {
            // Trier par score de priorit√© d√©croissant, puis par index croissant
            if (DEBUG_MODE) {
              closePoints.forEach(function(p) {
                const score = getPriorityScore(p.props);
                const priorite = p.props.priorite || 'd√©faut';
                const hasUrl = p.props.url && String(p.props.url).trim() !== '';
                console.log(`[DEBUG] Point ${p.num} (index ${p.i}) - Priorit√©: ${priorite}, Score: ${score}, URL: ${hasUrl ? 'oui' : 'non'}`);
              });
            }
            
            closePoints.sort(function(a, b) {
              const scoreA = getPriorityScore(a.props);
              const scoreB = getPriorityScore(b.props);
              if (scoreB !== scoreA) return scoreB - scoreA; // Plus haut score en premier
              return a.i - b.i; // Si √©gal, premier dans le fichier
            });
            preferredIndex = 0; // Le premier apr√®s tri est le privil√©gi√©
            
            const preferred = closePoints[preferredIndex];
            if (DEBUG_MODE) {
              console.log(`[DEBUG] Point privil√©gi√©: ${preferred.num} (index ${preferred.i}) - Score: ${getPriorityScore(preferred.props)}`);
              closePoints.forEach(function(p, idx) {
                if (idx !== preferredIndex) {
                  console.log(`[DEBUG] Point ${p.num} (index ${p.i}) sera d√©cal√© car moins prioritaire que ${preferred.num}`);
                }
              });
            }
          }
          
          // Le point privil√©gi√© garde ses coordonn√©es originales
          const preferred = closePoints[preferredIndex];
          preferred.isPreferred = true; // Marquer comme privil√©gi√©
          processedFeatures.push(preferred);
          processedIndices.add(preferred.i);
          
          // Les autres points sont d√©cal√©s en spirale
          let offsetCount = 1;
          for (let k = 0; k < closePoints.length; k++) {
            if (k === preferredIndex) continue;
            
            const point = closePoints[k];
            // D√©calage en spirale : chaque point est d√©cal√© de ~50m
            const angle = (offsetCount * 60) * (Math.PI / 180); // 60 degr√©s entre chaque point
            const offset = 0.0005 * offsetCount; // ~50m par niveau
            point.lat = point.originalLat + offset * Math.cos(angle);
            point.lng = point.originalLng + offset * Math.sin(angle);
            point.isPreferred = false; // Marquer comme non privil√©gi√© (d√©cal√©)
            
            processedFeatures.push(point);
            processedIndices.add(point.i);
            offsetCount++;
          }
        }
      }
      
      // Reconstruire avec les points, en s√©parant privil√©gi√©s et d√©cal√©s
      const offsetNormalFeatures = [];
      const preferredFeatures = [];
      
      normalFeatures.forEach(function(item) {
        const processed = processedFeatures.find(function(p) { return p.i === item.i; });
        let featureData = processed ? {
          f: processed.f,
          num: processed.num,
          i: processed.i,
          lat: processed.lat,
          lng: processed.lng,
          originalLat: processed.originalLat,
          originalLng: processed.originalLng,
          isPreferred: processed.isPreferred === true // Utiliser la propri√©t√© marqu√©e lors du traitement
        } : null;
        
        if (!featureData) {
          // Si non trouv√© (point sans coordonn√©es), retourner tel quel
          const coords = item.f.geometry && item.f.geometry.type === 'Point' ? item.f.geometry.coordinates : null;
          if (!coords) {
            offsetNormalFeatures.push({ f: item.f, num: item.num, i: item.i, lat: null, lng: null, isPreferred: false });
            return;
          }
          featureData = {
            f: item.f,
            num: item.num,
            i: item.i,
            lat: coords[1],
            lng: coords[0],
            originalLat: coords[1],
            originalLng: coords[0],
            isPreferred: false
          };
        }
        
        // S√©parer les points privil√©gi√©s des autres
        if (featureData.isPreferred && preferPriority) {
          preferredFeatures.push(featureData);
        } else {
          offsetNormalFeatures.push(featureData);
        }
      });

      // Regrouper les h√©bergements (ordre 0.0) en un seul point unique
      // D'abord, collecter toutes les features par emplacement
      const hebergementByCoord = new Map();
      hebergementFeatures.forEach(function(item) {
        const f = item.f;
        const coords = f.geometry && f.geometry.type === 'Point' ? f.geometry.coordinates : null;
        if (!coords) return;
        const lng = coords[0];
        const lat = coords[1];
        const coordKey = lat.toFixed(6) + ',' + lng.toFixed(6);
        
        if (!hebergementByCoord.has(coordKey)) {
          hebergementByCoord.set(coordKey, []);
        }
        hebergementByCoord.get(coordKey).push(f);
      });
      
      // Pour chaque emplacement, trouver la premi√®re feature avec un lien, sinon prendre la premi√®re
      const hebergementMap = new Map();
      hebergementByCoord.forEach(function(features, coordKey) {
        // Chercher la premi√®re feature avec un URL non vide
        let selectedFeature = features[0];
        let foundUrl = false;
        for (let i = 0; i < features.length; i++) {
          const props = features[i].properties || {};
          const url = props.url;
          // V√©rifier si l'URL existe et n'est pas vide (g√©rer null, undefined, cha√Æne vide)
          if (url !== null && url !== undefined && String(url).trim() !== '') {
            selectedFeature = features[i];
            foundUrl = true;
            break;
          }
        }
        
        const coords = selectedFeature.geometry && selectedFeature.geometry.type === 'Point' ? selectedFeature.geometry.coordinates : null;
        if (!coords) return;
        const lng = coords[0];
        const lat = coords[1];
        
        // S'assurer que les propri√©t√©s incluent bien l'URL si elle a √©t√© trouv√©e
        const finalProps = selectedFeature.properties || {};
        // Si on a trouv√© une feature avec URL, s'assurer que l'URL est bien dans les propri√©t√©s
        if (foundUrl && finalProps.url) {
          // L'URL est d√©j√† dans finalProps, pas besoin de modification
        }
        
        hebergementMap.set(coordKey, {
          f: selectedFeature,
          lat: lat,
          lng: lng,
          props: finalProps
        });
      });

      const group = L.featureGroup();

      // Fonction helper pour cr√©er un marqueur
      function createMarker(item, zIndexOffset) {
        const f = item.f;
        const num = item.num;
        const lat = item.lat;
        const lng = item.lng;
        if (lat === null || lng === null) return null;
        
        const props = f.properties || {};
        const priorite = props.priorite || '';
        const prioInfo = prioClass(priorite);
        const cls = prioInfo.cls;

        const iconHtml = '<div class="num-marker ' + cls + '">' + esc(num) + '</div>';
        const icon = L.divIcon({
          className: '',
          html: iconHtml,
          iconSize: [32, 32],
          iconAnchor: [16, 32],  // anchor bottom middle
          popupAnchor: [0, -28]
        });

        const marker = L.marker([lat, lng], { icon: icon });
        if (zIndexOffset) {
          marker.setZIndexOffset(zIndexOffset);
        }
        marker.bindPopup(makePopup(props, num), { maxWidth: 320 });
        
        // Enregistrer le marqueur pour le routage interactif
        if (typeof registerVisitMarkerForRouting === 'function') {
          registerVisitMarkerForRouting(marker, f);
        }
        
        return marker;
      }
      
      // Ajouter d'abord les points normaux (d√©cal√©s ou isol√©s)
      offsetNormalFeatures.forEach(function(item) {
        const marker = createMarker(item, 0);
        if (marker) {
          marker.addTo(group);
        }
      });
      
      // Ajouter ensuite les points privil√©gi√©s et les placer au-dessus
      const PRIORITY_Z_INDEX = 500; // Z-index pour les points privil√©gi√©s dans les groupes proches
      const preferredMarkers = [];
      preferredFeatures.forEach(function(item) {
        const marker = createMarker(item, PRIORITY_Z_INDEX);
        if (marker) {
          if (DEBUG_MODE) {
            console.log(`[DEBUG] Point privil√©gi√© ${item.num} ajout√© avec z-index ${PRIORITY_Z_INDEX}`);
          }
          marker.addTo(group);
          preferredMarkers.push(marker);
        }
      });

      // Ajouter les points d'h√©bergement (un seul par emplacement)
      hebergementMap.forEach(function(hebergement) {
        const props = hebergement.props;
        const lat = hebergement.lat;
        const lng = hebergement.lng;
        
        // Ic√¥ne d'habitation pour l'h√©bergement
        const iconHtml = '<div class="hebergement-marker">üè†</div>';
        const icon = L.divIcon({
          className: '',
          html: iconHtml,
          iconSize: [40, 40],
          iconAnchor: [20, 40],  // anchor bottom middle
          popupAnchor: [0, -35]
        });

        const marker = L.marker([lat, lng], { icon: icon });
        marker.bindPopup(makePopup(props, '0.0'), { maxWidth: 320 });
        
        // Enregistrer le marqueur d'h√©bergement pour le routage interactif
        if (typeof registerVisitMarkerForRouting === 'function' && hebergement.f) {
          registerVisitMarkerForRouting(marker, hebergement.f);
        }
        
        marker.addTo(group);
      });
      

      group.addTo(map);
      
      // Forcer les points privil√©gi√©s √† √™tre au-dessus
      // Dans Leaflet, on doit r√©organiser les layers du groupe pour mettre les privil√©gi√©s en dernier
      // Le dernier layer ajout√© au groupe sera au-dessus visuellement
      if (preferredMarkers.length > 0) {
        preferredMarkers.forEach(function(marker) {
          // Retirer le marqueur du groupe
          group.removeLayer(marker);
          // Le r√©ajouter en dernier (ce qui le place au-dessus)
          group.addLayer(marker);
          if (DEBUG_MODE) {
            const popup = marker.getPopup();
            const content = popup ? popup.getContent() : '';
            const numMatch = content.match(/(\d+\.\d+)/);
            const num = numMatch ? numMatch[0] : '?';
            console.log(`[DEBUG] Point privil√©gi√© ${num} forc√© au premier plan en le r√©ajoutant au groupe`);
          }
        });
      }

      // Zoom sur l'ensemble des points (avec marge)
      const b = group.getBounds();
      if (b.isValid()) {
        map.fitBounds(b.pad(0.15));
        
        // V√©rifier la visibilit√© des points prioritaires apr√®s le zoom
        if (typeof priorityMarkers !== 'undefined' && priorityMarkers.length > 0) {
          priorityMarkers.forEach(function(marker) {
            const markerBounds = L.latLngBounds([marker.getLatLng()]);
            const isVisible = b.contains(markerBounds);
            if (!isVisible) {
              // Centrer la carte sur le point prioritaire si n√©cessaire
              map.setView(marker.getLatLng(), 15);
            }
          });
        }
      } else {
        map.setView([41.9028, 12.4964], 12); // Rome fallback
      }
    }

    loadGeoJson().catch(err => {
      console.error(err);
      alert("Erreur : " + err.message);
      map.setView([41.9028, 12.4964], 12);
    });
  </script>
</body>
</html>