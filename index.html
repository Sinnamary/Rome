<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Rome 2026 ‚Äî Visites (GeoJSON)</title>
  <link rel="icon" type="image/svg+xml" href="favicon.svg" />

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
          integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; width: 100%; }

    /* Numbered circle marker (DivIcon) */
    .num-marker{
      width: 32px; height: 32px;
      border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
      font: 700 14px/1 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: #fff;
      border: 2px solid rgba(255,255,255,0.9);
      box-shadow: 0 2px 8px rgba(0,0,0,0.35);
    }
    .prio-haute { background: #c62828; }
    .prio-moyenne { background: #ef6c00; }
    .prio-basse { background: #2e7d32; }
    .prio-defaut { background: #0d47a1; }

    /* Popup layout */
    .popup h3 { margin: 0 0 6px 0; font-size: 16px; }
    .popup .meta { margin: 0; padding: 0; list-style: none; }
    .popup .meta li { margin: 2px 0; }
    .badge {
      display: inline-block; padding: 2px 8px; border-radius: 999px;
      font-size: 12px; font-weight: 600; color: #fff; vertical-align: middle;
    }
    .badge-haute { background:#c62828; }
    .badge-moyenne { background:#ef6c00; }
    .badge-basse { background:#2e7d32; }
    .badge-defaut { background:#0d47a1; }
    .muted { color: #555; }
    .popup a { word-break: break-all; }
    /* Styles pour les lignes de trajet */
    .route-line {
      cursor: pointer;
      transition: opacity 0.2s;
    }
    
    .route-line:hover {
      opacity: 1 !important;
      stroke-width: 5 !important;
    }
    
    /* Styles pour le contr√¥leur de calques */
    .leaflet-control-layers {
      background: white;
      border-radius: 4px;
      box-shadow: 0 1px 5px rgba(0,0,0,0.4);
    }
    
    .leaflet-control-layers-overlays label {
      display: block;
      padding: 4px 8px;
      cursor: pointer;
    }
    
    .leaflet-control-layers-overlays label:hover {
      background-color: #f0f0f0;
    }

  </style>
</head>
<body>
  <div id="map"></div>

  <script>
    // ============================================================
    // MODULE ROUTES - Gestion des calques de trajets
    // ============================================================
    // Ce code est compl√®tement ind√©pendant du code principal
    // Il g√®re uniquement l'affichage des trajets entre les points
    
    class RouteLayerManager {
      constructor(map) {
        this.map = map;
        this.routeLayers = new Map(); // Map<jour, L.layerGroup>
        this.dayColors = [
          "#2563eb", // Bleu - Jour 1
          "#16a34a", // Vert - Jour 2
          "#ea580c", // Orange - Jour 3
          "#9333ea", // Violet - Jour 4
          "#dc2626", // Rouge - Jour 5
          "#0891b2", // Cyan - Jour 6
          "#ca8a04", // Jaune - Jour 7
        ];
        this.layerControl = null;
      }
      
      /**
       * Parse le num√©ro d'ordre pour extraire le jour
       * Format attendu : "J.N" (ex: "1.1", "2.3", "3.1")
       */
      parseDayFromOrder(orderStr) {
        if (!orderStr || typeof orderStr !== 'string') return null;
        const match = orderStr.match(/^(\d+)\./);
        return match ? parseInt(match[1], 10) : null;
      }
      
      /**
       * Parse le num√©ro d'ordre pour extraire le num√©ro de visite
       * Format attendu : "J.N" (ex: "1.1", "2.3", "3.1")
       */
      parseVisitFromOrder(orderStr) {
        if (!orderStr || typeof orderStr !== 'string') return null;
        const match = orderStr.match(/\.(\d+)$/);
        return match ? parseInt(match[1], 10) : null;
      }
      
      /**
       * Calcule la distance en m√®tres entre deux points (formule de Haversine)
       */
      calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371000; // Rayon de la Terre en m√®tres
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLon = (lon2 - lon1) * Math.PI / 180;
        const a = 
          Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
          Math.sin(dLon / 2) * Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
      }
      
      /**
       * Formate la distance pour l'affichage
       */
      formatDistance(meters) {
        if (meters < 1000) {
          return Math.round(meters) + " m";
        }
        return (meters / 1000).toFixed(2) + " km";
      }
      
      /**
       * Cr√©e une polyligne entre deux points avec des informations
       */
      createRouteLine(point1, point2, color) {
        const lat1 = point1.lat;
        const lon1 = point1.lon;
        const lat2 = point2.lat;
        const lon2 = point2.lon;
        
        const distance = this.calculateDistance(lat1, lon1, lat2, lon2);
        const distanceText = this.formatDistance(distance);
        
        // R√©cup√©rer le temps de trajet depuis le point d'arriv√©e (point2)
        // Le temps de trajet est associ√© au point d'arriv√©e dans le tableau Excel
        const tempsTrajet = point2.temps_trajet || '';
        const tempsTrajetText = tempsTrajet ? `Temps: ${tempsTrajet}` : '';
        
        // Cr√©er la polyligne
        const polyline = L.polyline(
          [[lat1, lon1], [lat2, lon2]],
          {
            color: color,
            weight: 4,
            opacity: 0.7,
            dashArray: '10, 5',
            className: 'route-line'
          }
        );
        
        // Construire le contenu du popup
        let popupLines = [
          `<strong>${point1.order} ‚Üí ${point2.order}</strong>`,
          `<span style="color: #666;">Distance: ${distanceText}</span>`
        ];
        
        if (tempsTrajetText) {
          popupLines.push(`<span style="color: #666;">${tempsTrajetText}</span>`);
        }
        
        // Ajouter un popup avec les informations
        const popupContent = `
          <div style="text-align: center;">
            ${popupLines.join('<br>')}
          </div>
        `;
        polyline.bindPopup(popupContent);
        
        return polyline;
      }
      
      /**
       * Groupe les points par jour et trie par ordre de visite
       */
      groupPointsByDay(features) {
        const pointsByDay = new Map();
        
        features.forEach((feature, index) => {
          const props = feature.properties || {};
          const order = String(props.ordre || props.numero || props.visite || (index + 1));
          const day = this.parseDayFromOrder(order);
          
          if (day === null) return; // Ignorer si pas de jour valide
          
          const coords = feature.geometry && feature.geometry.coordinates;
          if (!coords || coords.length < 2) return;
          
          const point = {
            order: order,
            day: day,
            visit: this.parseVisitFromOrder(order),
            lat: coords[1],
            lon: coords[0],
            name: props.name || `Point ${order}`,
            temps_trajet: props.temps_trajet || '',
            index: index
          };
          
          if (!pointsByDay.has(day)) {
            pointsByDay.set(day, []);
          }
          pointsByDay.get(day).push(point);
        });
        
        // Trier les points de chaque jour par num√©ro de visite
        pointsByDay.forEach((points, day) => {
          points.sort((a, b) => {
            if (a.visit === null && b.visit === null) return 0;
            if (a.visit === null) return 1;
            if (b.visit === null) return -1;
            return a.visit - b.visit;
          });
        });
        
        return pointsByDay;
      }
      
      /**
       * Cr√©e les calques de trajets pour tous les jours
       */
      createRouteLayers(features) {
        // Nettoyer les calques existants
        this.clearRouteLayers();
        
        // Grouper les points par jour
        const pointsByDay = this.groupPointsByDay(features);
        
        if (pointsByDay.size === 0) {
          console.log("[ROUTES] Aucun point valide trouv√© pour cr√©er les trajets");
          return;
        }
        
        // Cr√©er un calque pour chaque jour
        pointsByDay.forEach((points, day) => {
          const color = this.dayColors[(day - 1) % this.dayColors.length];
          const layerGroup = L.layerGroup();
          
          // Tracer les lignes entre les points cons√©cutifs
          for (let i = 0; i < points.length - 1; i++) {
            const point1 = points[i];
            const point2 = points[i + 1];
            
            const routeLine = this.createRouteLine(point1, point2, color);
            routeLine.addTo(layerGroup);
          }
          
          // Stocker le calque
          this.routeLayers.set(day, {
            layer: layerGroup,
            color: color,
            day: day,
            pointCount: points.length
          });
        });
        
        console.log(`[ROUTES] ${this.routeLayers.size} calque(s) de trajet cr√©√©(s)`);
      }
      
      /**
       * Nettoie tous les calques de trajets existants
       */
      clearRouteLayers() {
        this.routeLayers.forEach((routeData, day) => {
          if (this.map.hasLayer(routeData.layer)) {
            this.map.removeLayer(routeData.layer);
          }
        });
        this.routeLayers.clear();
      }
      
      /**
       * Ajoute le contr√¥leur de calques √† la carte
       */
      addLayerControl(baseLayers, overlayLayers) {
        // Supprimer l'ancien contr√¥leur s'il existe
        if (this.layerControl) {
          this.map.removeControl(this.layerControl);
        }
        
        // Cr√©er le nouveau contr√¥leur avec les calques de trajets
        const routeOverlays = {};
        this.routeLayers.forEach((routeData, day) => {
          routeOverlays[`Trajets - Jour ${day}`] = routeData.layer;
        });
        
        // Fusionner avec les overlays existants
        const allOverlays = { ...overlayLayers, ...routeOverlays };
        
        this.layerControl = L.control.layers(baseLayers, allOverlays, {
          position: 'topright',
          collapsed: true
        });
        
        this.layerControl.addTo(this.map);
      }
      
      /**
       * Active tous les calques de trajets
       */
      showAllRoutes() {
        this.routeLayers.forEach((routeData, day) => {
          if (!this.map.hasLayer(routeData.layer)) {
            routeData.layer.addTo(this.map);
          }
        });
      }
      
      /**
       * D√©sactive tous les calques de trajets
       */
      hideAllRoutes() {
        this.routeLayers.forEach((routeData, day) => {
          if (this.map.hasLayer(routeData.layer)) {
            this.map.removeLayer(routeData.layer);
          }
        });
      }
    }
    
    // Variable globale pour le gestionnaire de routes
    let routeManager = null;
    
    /**
     * Initialise le gestionnaire de routes
     */
    function initRouteManager(map) {
      if (!routeManager) {
        routeManager = new RouteLayerManager(map);
        console.log("[ROUTES] Gestionnaire de routes initialis√©");
      }
      return routeManager;
    }
    
    /**
     * Traite les features GeoJSON pour cr√©er les trajets
     */
    function processRoutes(features) {
      // Initialiser le gestionnaire si n√©cessaire
      if (!routeManager) {
        if (typeof map !== 'undefined') {
          routeManager = initRouteManager(map);
        } else {
          console.warn("[ROUTES] La carte n'est pas encore initialis√©e");
          return;
        }
      }
      
      routeManager.createRouteLayers(features);
      
      // Ajouter le contr√¥leur de calques
      const baseLayers = {};
      const overlayLayers = {};
      routeManager.addLayerControl(baseLayers, overlayLayers);
      
      // Les calques sont cr√©√©s mais non activ√©s par d√©faut
      // L'utilisateur peut les activer via le contr√¥leur de calques
    }
    
    // ============================================================
    // FIN DU MODULE ROUTES
    // ============================================================

    // Int√©gration des routes dans le processus principal
    // Appeler cette fonction apr√®s avoir charg√© et trait√© le GeoJSON
    
    function integrateRoutes(features) {
      // S'assurer que la carte est initialis√©e
      if (typeof map === 'undefined') {
        console.warn("[ROUTES] La carte n'est pas encore initialis√©e, attente...");
        setTimeout(() => integrateRoutes(features), 100);
        return;
      }
      
      // Initialiser le gestionnaire si n√©cessaire
      if (!routeManager) {
        routeManager = initRouteManager(map);
      }
      
      processRoutes(features);
    }


    // ‚úÖ URL du fichier GeoJSON sur GitHub
    const GEOJSON_URL = "https://raw.githubusercontent.com/Sinnamary/Rome/main/attractions_rome_2026-01-02.geojson";

    const map = L.map('map', { zoomControl: true });

    // Fond de carte (OpenStreetMap)
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    function esc(s){
      return String(s ?? '').replace(/[&<>"']/g, (c)=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c]));
    }

    function prioClass(prio){
      const p = String(prio ?? '').toLowerCase().trim();
      if (p === 'haute') return { cls: 'prio-haute', badge: 'badge-haute' };
      if (p === 'moyenne') return { cls: 'prio-moyenne', badge: 'badge-moyenne' };
      if (p === 'basse') return { cls: 'prio-basse', badge: 'badge-basse' };
      return { cls: 'prio-defaut', badge: 'badge-defaut' };
    }

    function formatReservation(v){
      if (v === true || String(v).toLowerCase() === 'true') return 'Oui';
      if (v === false || String(v).toLowerCase() === 'false') return 'Non';
      return esc(v);
    }

    function makePopup(props, num){
      const name = props.name ?? `Visite ${num}`;
      const date = props.date ?? '';
      const debut = props.heure_debut ?? '';
      const fin = props.heure_fin ?? '';
      const duree = props.duree ?? '';
      const prix = (props.prix ?? props.price ?? '');
      const reservation = formatReservation(props.reservation);
      const url = props.url ?? '';
      const description = props.description ?? '';
      const priorite = props.priorite ?? '';

      const { badge } = prioClass(priorite);

      // Capitaliser la premi√®re lettre pour l'affichage
      const prioriteDisplay = priorite 
        ? priorite.charAt(0).toUpperCase() + priorite.slice(1).toLowerCase()
        : '';

      const badgeHtml = priorite
        ? ` <span class="badge ${badge}">${esc(prioriteDisplay)}</span>`
        : '';

      const horaire = (debut || fin) ? `${esc(debut)}${(debut && fin) ? ' ‚Äì ' : ''}${esc(fin)}` : '';

      const lienUrl = url
        ? `<li>üîó <strong>Lien</strong> : <a href="${esc(url)}" target="_blank" rel="noopener">ouvrir</a></li>`
        : '';

      const prixTxt = (prix === 0 || prix === "0") ? "0 ‚Ç¨" : (prix ? `${esc(prix)} ‚Ç¨` : '');

      return `
        <div class="popup">
          <h3>${esc(num)}. ${esc(name)}${badgeHtml}</h3>
          <ul class="meta">
            ${date ? `<li>üìÖ <strong>Date</strong> : ${esc(date)}</li>` : ''}
            ${horaire ? `<li>‚è∞ <strong>Horaire</strong> : ${esc(horaire)}</li>` : ''}
            ${duree ? `<li>‚è± <strong>Dur√©e</strong> : ${esc(duree)}</li>` : ''}
            ${prixTxt ? `<li>üí∂ <strong>Prix</strong> : ${prixTxt}</li>` : ''}
            ${(props.reservation !== undefined && props.reservation !== null) ? `<li>üìû <strong>R√©servation</strong> : ${esc(reservation)}</li>` : ''}
            ${lienUrl}
          </ul>
          ${description ? `<p class="muted" style="margin:8px 0 0 0;">${esc(description)}</p>` : ''}
        </div>
      `;
    }

    async function loadGeoJson(){
      const res = await fetch(GEOJSON_URL, { cache: 'no-store' });
      if (!res.ok) throw new Error(`Impossible de charger le GeoJSON (${res.status})`);
      const gj = await res.json();
      processGeoJSON(gj);
    // Int√©gration des routes dans le processus principal
    // Appeler cette fonction apr√®s avoir charg√© et trait√© le GeoJSON
    
    function integrateRoutes(features) {
      // S'assurer que la carte est initialis√©e
      if (typeof map === 'undefined') {
        console.warn("[ROUTES] La carte n'est pas encore initialis√©e, attente...");
        setTimeout(() => integrateRoutes(features), 100);
        return;
      }
      
      // Initialiser le gestionnaire si n√©cessaire
      if (!routeManager) {
        routeManager = initRouteManager(map);
      }
      
      processRoutes(features);
    }

      // Int√©grer les routes apr√®s traitement du GeoJSON
      if (typeof integrateRoutes === 'function') {
        integrateRoutes(gj.features || []);
      }
    }
    
    function processGeoJSON(gj) {
      // Num√©rotation: si props.ordre / props.numero / props.visite existent => on les utilise, sinon index + 1
      const features = (gj.features ?? []).map((f, i) => {
        const p = f.properties ?? {};
        // Convertir en cha√Æne pour garantir la coh√©rence
        const num = String(p.ordre ?? p.numero ?? p.visite ?? p.id ?? (i + 1));
        return { f, num, i };
      });

      // D√©tecter et g√©rer les points superpos√©s (m√™mes coordonn√©es)
      const coordMap = new Map();
      const offsetFeatures = features.map(function(item) {
        const f = item.f;
        const num = item.num;
        const i = item.i;
        const coords = f.geometry && f.geometry.type === 'Point' ? f.geometry.coordinates : null;
        if (!coords) return { f: f, num: num, i: i, lat: null, lng: null };
        const lng = coords[0];
        const lat = coords[1];
        const coordKey = lat.toFixed(6) + ',' + lng.toFixed(6);
        
        // Compter combien de points ont ces coordonn√©es
        const count = coordMap.get(coordKey) || 0;
        coordMap.set(coordKey, count + 1);
        
        // Si plusieurs points ont les m√™mes coordonn√©es, les d√©caler l√©g√®rement
        let offsetLat = lat;
        let offsetLng = lng;
        if (count > 0) {
          // D√©calage en spirale : chaque point est d√©cal√© de ~50m
          const angle = (count * 60) * (Math.PI / 180); // 60 degr√©s entre chaque point
          const offset = 0.0005 * count; // ~50m par niveau
          offsetLat = lat + offset * Math.cos(angle);
          offsetLng = lng + offset * Math.sin(angle);
        }
        
        return { f: f, num: num, i: i, lat: offsetLat, lng: offsetLng, originalLat: lat, originalLng: lng };
      });

      const group = L.featureGroup();

      offsetFeatures.forEach(function(item) {
        const f = item.f;
        const num = item.num;
        const lat = item.lat;
        const lng = item.lng;
        if (lat === null || lng === null) return;
        
        const props = f.properties || {};
        const priorite = props.priorite || '';
        const prioInfo = prioClass(priorite);
        const cls = prioInfo.cls;

        const iconHtml = '<div class="num-marker ' + cls + '">' + esc(num) + '</div>';
        const icon = L.divIcon({
          className: '',
          html: iconHtml,
          iconSize: [32, 32],
          iconAnchor: [16, 32],  // anchor bottom middle
          popupAnchor: [0, -28]
        });

        const marker = L.marker([lat, lng], { icon: icon });
        marker.bindPopup(makePopup(props, num), { maxWidth: 320 });
        marker.addTo(group);
      });
      
      // V√©rifier sp√©cifiquement le point 2.2 pour s'assurer qu'il est visible
      const marker22 = group.getLayers().find(layer => {
        if (layer instanceof L.Marker) {
          const popup = layer.getPopup();
          if (popup) {
            const content = popup.getContent();
            return content && content.includes('2.2');
          }
        }
        return false;
      });
      
      if (marker22) {
        // Forcer le point 2.2 √† √™tre visible
        marker22.setZIndexOffset(1000);
      }

      group.addTo(map);

      // Zoom sur l'ensemble des points (avec marge)
      const b = group.getBounds();
      if (b.isValid()) {
        map.fitBounds(b.pad(0.15));
        
        // V√©rifier si le point 2.2 est dans les bounds
        if (marker22) {
          const bounds22 = L.latLngBounds([marker22.getLatLng()]);
          const isVisible = b.contains(bounds22);
          if (!isVisible) {
            // Centrer la carte sur le point 2.2 si n√©cessaire
            map.setView(marker22.getLatLng(), 15);
          }
        }
      } else {
        map.setView([41.9028, 12.4964], 12); // Rome fallback
      }
    }

    loadGeoJson().catch(err => {
      console.error(err);
      alert("Erreur : " + err.message);
      map.setView([41.9028, 12.4964], 12);
    });
  </script>
</body>
</html>