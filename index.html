<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Rome 2026</title>
  <link rel="icon" type="image/svg+xml" href="favicon.svg" />

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
          integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; width: 100%; }

    /* Numbered circle marker (DivIcon) */
    .num-marker{
      width: 32px; height: 32px;
      border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
      font: 700 14px/1 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: #fff;
      border: 2px solid rgba(255,255,255,0.9);
      box-shadow: 0 2px 8px rgba(0,0,0,0.35);
    }
    .prio-haute { background: #c62828; }
    .prio-moyenne { background: #ef6c00; }
    .prio-basse { background: #2e7d32; }
    .prio-defaut { background: #0d47a1; }

    /* H√©bergement marker (ordre 0.0) */
    .hebergement-marker{
      width: 40px; height: 40px;
      border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
      font-size: 24px;
      background: #1e3a8a;
      border: 3px solid rgba(255,255,255,0.95);
      box-shadow: 0 3px 10px rgba(0,0,0,0.4);
    }

    /* Popup layout */
    .popup h3 { margin: 0 0 6px 0; font-size: 16px; }
    .popup .meta { margin: 0; padding: 0; list-style: none; }
    .popup .meta li { margin: 2px 0; }
    .badge {
      display: inline-block; padding: 2px 8px; border-radius: 999px;
      font-size: 12px; font-weight: 600; color: #fff; vertical-align: middle;
    }
    .badge-haute { background:#c62828; }
    .badge-moyenne { background:#ef6c00; }
    .badge-basse { background:#2e7d32; }
    .badge-defaut { background:#0d47a1; }
    .muted { color: #555; }
    .popup a { word-break: break-all; }
    .route-line {
      cursor: pointer;
      transition: opacity 0.2s;
    }
    
    .route-line:hover {
      opacity: 1 !important;
      stroke-width: 5 !important;
    }
    
    .leaflet-control-layers {
      background: white;
      border-radius: 4px;
      box-shadow: 0 1px 5px rgba(0,0,0,0.4);
    }
    
    .leaflet-control-layers-overlays label {
      display: block;
      padding: 4px 8px;
      cursor: pointer;
    }
    
    .leaflet-control-layers-overlays label:hover {
      background-color: #f0f0f0;
    }
    /* Styles pour le calque hop-on hop-off */
    .hoponhopoff-route {
      cursor: pointer;
    }
    
    .hoponhopoff-route:hover {
      opacity: 1;
      stroke-width: 6;
    }
    
    .hoponhopoff-stop-icon {
      background: transparent;
      border: none;
    }
    
    .hoponhopoff-stop-marker {
      width: 32px;
      height: 32px;
      background: transparent;
      border: none;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: transform 0.2s ease;
      position: relative;
    }
    
    .hoponhopoff-stop-marker::before {
      content: 'üöå';
      font-size: 32px;
      line-height: 1;
      filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
    }
    
    .hoponhopoff-stop-marker:hover {
      transform: scale(1.2);
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <script>
    // ============================================================
    // MODULE ROUTES - Gestion des calques de trajets
    // ============================================================
    // Ce code est compl√®tement ind√©pendant du code principal
    // Il g√®re uniquement l'affichage des trajets entre les points
        class RouteLayerManager {
      constructor(map) {
        this.map = map;
        this.routeLayers = new Map();
        this.pointLayers = new Map();
        this.dayColors = ["#2563eb", "#16a34a", "#ea580c", "#9333ea", "#dc2626", "#0891b2", "#ca8a04"];
        this.layerControl = null;
      }
      parseDayFromOrder(orderStr) {
        if (!orderStr || typeof orderStr !== 'string') return null;
        // G√©rer l'ordre 0.0 (h√©bergement) - utiliser la date pour d√©terminer le jour
        if (orderStr === '0.0' || orderStr === '0' || parseFloat(orderStr) === 0.0) {
          return 0; // Retourner 0 pour indiquer que c'est un h√©bergement
        }
        const match = orderStr.match(/^(\d+)\./);
        return match ? parseInt(match[1], 10) : null;
      }
      
      parseVisitFromOrder(orderStr) {
        if (!orderStr || typeof orderStr !== 'string') return null;
        const match = orderStr.match(/\.(\d+)$/);
        return match ? parseInt(match[1], 10) : null;
      }
      calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371000;
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLon = (lon2 - lon1) * Math.PI / 180;
        const a = 
          Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
          Math.sin(dLon / 2) * Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
      }
      
      formatDistance(meters) {
        if (meters < 1000) {
          return Math.round(meters) + " m";
        }
        return (meters / 1000).toFixed(2) + " km";
      }
      
      parseDistance(distanceStr) {
        // Parse une distance au format "30.5 km" ou "850 m" en m√®tres
        if (!distanceStr || typeof distanceStr !== 'string') return null;
        const str = distanceStr.trim().toLowerCase();
        // Regex pour km: nombre suivi de "km"
        const kmRegex = /([\d.]+)\s*km/;
        const kmMatch = str.match(kmRegex);
        if (kmMatch) {
          return parseFloat(kmMatch[1]) * 1000;
        }
        // Regex pour m: nombre suivi de "m" (mais pas "km")
        const mRegex = /([\d.]+)\s*m(?!m)/;
        const mMatch = str.match(mRegex);
        if (mMatch) {
          return parseFloat(mMatch[1]);
        }
        // Essayer de parser comme nombre simple (suppos√© en km)
        const numRegex = /([\d.]+)/;
        const numMatch = str.match(numRegex);
        if (numMatch) {
          const num = parseFloat(numMatch[1]);
          // Si < 10, supposer km, sinon m√®tres
          return num < 10 ? num * 1000 : num;
        }
        return null;
      }
      
      calculateTravelTime(distanceMeters, transport) {
        // Vitesses moyennes en m/s selon le moyen de transport
        const speeds = {
          'marche': 1.4,      // 5 km/h = 1.4 m/s
          'pied': 1.4,        // 5 km/h = 1.4 m/s
          'velo': 4.2,        // 15 km/h = 4.2 m/s
          'v√©lo': 4.2,        // 15 km/h = 4.2 m/s
          'metro': 8.3,       // 30 km/h = 8.3 m/s
          'm√©tro': 8.3,       // 30 km/h = 8.3 m/s
          'bus': 6.9,         // 25 km/h = 6.9 m/s
          'train': 13.9,      // 50 km/h = 13.9 m/s
          'voiture': 11.1,    // 40 km/h en ville = 11.1 m/s
          'taxi': 11.1,       // 40 km/h en ville = 11.1 m/s
          'default': 1.4      // Par d√©faut: marche (5 km/h)
        };
        
        if (!distanceMeters || distanceMeters <= 0) return null;
        
        const transportLower = (transport || '').toLowerCase().trim();
        const speed = speeds[transportLower] || speeds['default'];
        const timeSeconds = distanceMeters / speed;
        const timeMinutes = Math.round(timeSeconds / 60);
        
        if (timeMinutes < 1) return '< 1 min';
        if (timeMinutes < 60) return timeMinutes + ' min';
        const hours = Math.floor(timeMinutes / 60);
        const minutes = timeMinutes % 60;
        return hours + 'h' + (minutes > 0 ? minutes + 'min' : '');
      }
      createRouteLine(point1, point2, color) {
        const lat1 = point1.lat;
        const lon1 = point1.lon;
        const lat2 = point2.lat;
        const lon2 = point2.lon;
        
        // Utiliser la distance manuelle si pr√©sente, sinon calculer automatiquement
        let distanceText;
        let distanceMeters = null;
        if (point2.distance && point2.distance.trim() !== '') {
          // Distance manuelle renseign√©e dans le fichier Excel
          distanceText = point2.distance.trim();
          distanceMeters = this.parseDistance(distanceText);
        } else {
          // Calculer automatiquement la distance √† vol d'oiseau
          distanceMeters = this.calculateDistance(lat1, lon1, lat2, lon2);
          distanceText = this.formatDistance(distanceMeters);
        }
        
        // R√©cup√©rer le temps de trajet et le transport
        const tempsTrajet = point2.temps_trajet || '';
        const transport = point2.transport || '';
        
        // Calculer le temps de trajet si absent
        let tempsTrajetText = '';
        if (tempsTrajet && tempsTrajet.trim() !== '') {
          // Temps renseign√© manuellement
          tempsTrajetText = tempsTrajet.trim();
        } else if (distanceMeters && distanceMeters > 0) {
          // Calculer le temps bas√© sur la distance et le moyen de transport
          const transportMode = transport || 'marche'; // Par d√©faut: marche
          const calculatedTime = this.calculateTravelTime(distanceMeters, transportMode);
          if (calculatedTime) {
            tempsTrajetText = calculatedTime + ' (estim√©)';
          }
        }
        
        const polyline = L.polyline(
          [[lat1, lon1], [lat2, lon2]],
          {
            color: color,
            weight: 4,
            opacity: 0.7,
            dashArray: '10, 5',
            className: 'route-line'
          }
        );
        
        // Construire le contenu de la popup
        let popupLines = [
          '<strong>' + point1.order + ' ‚Üí ' + point2.order + '</strong>',
          '<hr style="margin: 5px 0; border: none; border-top: 1px solid #ddd;">'
        ];
        
        // Distance
        popupLines.push('<span style="color: #666;"><strong>Distance:</strong> ' + distanceText + '</span>');
        
        // Temps de trajet
        if (tempsTrajetText) {
          popupLines.push('<span style="color: #666;"><strong>Temps:</strong> ' + tempsTrajetText + '</span>');
        }
        
        // Moyen de transport
        if (transport && transport.trim() !== '') {
          const transportDisplay = transport.charAt(0).toUpperCase() + transport.slice(1).toLowerCase();
          popupLines.push('<span style="color: #666;"><strong>Transport:</strong> ' + transportDisplay + '</span>');
        }
        
        const popupContent = '<div style="text-align: center; padding: 5px;">' + popupLines.join('<br>') + '</div>';
        polyline.bindPopup(popupContent);
        
        return polyline;
      }
      groupPointsByDay(features) {
        const pointsByDay = new Map();
        
        // D'abord, collecter toutes les dates pour mapper les h√©bergements (ordre 0.0) aux jours
        const dateToDayMap = new Map();
        features.forEach((feature) => {
          const props = feature.properties || {};
          const order = String(props.ordre || props.numero || props.visite || '');
          const date = props.date || '';
          // Si ce n'est pas un h√©bergement, extraire le jour de l'ordre
          if (order !== '0.0' && order !== '0' && parseFloat(order) !== 0.0) {
            const day = this.parseDayFromOrder(order);
            if (day !== null && day !== 0 && date) {
              // Mapper la date au jour pour les points normaux
              if (!dateToDayMap.has(date)) {
                dateToDayMap.set(date, day);
              }
            }
          }
        });
        
        features.forEach((feature, index) => {
          const props = feature.properties || {};
          const order = String(props.ordre || props.numero || props.visite || (index + 1));
          const date = props.date || '';
          let day = this.parseDayFromOrder(order);
          
          // Si c'est un h√©bergement (ordre 0.0), utiliser la date pour d√©terminer le jour
          if (day === 0) {
            // Chercher le jour correspondant √† cette date
            day = dateToDayMap.get(date);
            // Si pas trouv√©, essayer de d√©duire du premier point non-h√©bergement de cette date
            if (!day) {
              // Parcourir les features pour trouver le premier point non-h√©bergement de cette date
              for (let i = 0; i < features.length; i++) {
                const f = features[i];
                const p = f.properties || {};
                const o = String(p.ordre || p.numero || p.visite || '');
                const d = p.date || '';
                if (d === date && o !== '0.0' && o !== '0' && parseFloat(o) !== 0.0) {
                  day = this.parseDayFromOrder(o);
                  if (day !== null && day !== 0) {
                    dateToDayMap.set(date, day);
                    break;
                  }
                }
              }
            }
            // Si toujours pas trouv√©, utiliser 1 par d√©faut
            if (!day) day = 1;
          }
          
          if (day === null) return;
          
          const coords = feature.geometry && feature.geometry.coordinates;
          if (!coords || coords.length < 2) return;
          
          const point = {
            order: order,
            day: day,
            visit: this.parseVisitFromOrder(order),
            lat: coords[1],
            lon: coords[0],
            name: props.name || 'Point ' + order,
            temps_trajet: props.temps_trajet || '',
            distance: props.distance || '',
            transport: props.transport || '',
            index: index,
            isHebergement: (order === '0.0' || order === '0' || parseFloat(order) === 0.0)
          };
          
          if (!pointsByDay.has(day)) {
            pointsByDay.set(day, []);
          }
          pointsByDay.get(day).push(point);
        });
        
        pointsByDay.forEach((points, day) => {
          points.sort((a, b) => {
            // Pour les h√©bergements (ordre 0.0), pr√©server l'ordre original (index)
            if (a.isHebergement && b.isHebergement) {
              return a.index - b.index;
            }
            if (a.isHebergement) {
              // H√©bergement avant les points normaux (sera ajust√© selon le jour dans le tri final)
              return -1;
            }
            if (b.isHebergement) {
              // Points normaux apr√®s les h√©bergements
              return 1;
            }
            
            // Pour les points normaux, utiliser le num√©ro de visite
            if (a.visit === null && b.visit === null) return 0;
            if (a.visit === null) return 1;
            if (b.visit === null) return -1;
            return a.visit - b.visit;
          });
          
          // Ajuster l'ordre des h√©bergements selon le jour
          const allDays = Array.from(pointsByDay.keys()).sort((x, y) => x - y);
          const isFirstDay = day === allDays[0];
          const isLastDay = day === allDays[allDays.length - 1];
          
          // S√©parer les h√©bergements des points normaux
          const hebergements = points.filter(p => p.isHebergement);
          const normalPoints = points.filter(p => !p.isHebergement);
          
          if (hebergements.length > 0) {
            if (isFirstDay) {
              // Premier jour : h√©bergement √† la fin uniquement
              pointsByDay.set(day, [...normalPoints, ...hebergements]);
            } else if (isLastDay) {
              // Dernier jour : h√©bergement au d√©but uniquement
              pointsByDay.set(day, [...hebergements, ...normalPoints]);
            } else {
              // Jours interm√©diaires : h√©bergement au d√©but et √† la fin
              // Garder l'ordre original (premier h√©bergement au d√©but, dernier √† la fin)
              if (hebergements.length >= 2) {
                pointsByDay.set(day, [hebergements[0], ...normalPoints, ...hebergements.slice(1)]);
              } else {
                // Si un seul h√©bergement, le placer au d√©but
                pointsByDay.set(day, [...hebergements, ...normalPoints]);
              }
            }
          }
        });
        
        return pointsByDay;
      }
      createMarker(feature, lat, lng, order) {
        const props = feature.properties || {};
        const orderStr = String(order);
        const isHebergement = (orderStr === '0.0' || orderStr === '0' || parseFloat(orderStr) === 0.0);
        
        let iconHtml, iconSize, iconAnchor, popupAnchor;
        
        if (isHebergement) {
          // Ic√¥ne d'h√©bergement
          iconHtml = '<div class="hebergement-marker">üè†</div>';
          iconSize = [40, 40];
          iconAnchor = [20, 40];
          popupAnchor = [0, -35];
        } else {
          // Ic√¥ne normale avec num√©ro
          const priorite = props.priorite || '';
          const prioInfo = prioClass(priorite);
          const cls = prioInfo.cls;
          iconHtml = '<div class="num-marker ' + cls + '">' + esc(order) + '</div>';
          iconSize = [32, 32];
          iconAnchor = [16, 32];
          popupAnchor = [0, -28];
        }
        
        const icon = L.divIcon({
          className: '',
          html: iconHtml,
          iconSize: iconSize,
          iconAnchor: iconAnchor,
          popupAnchor: popupAnchor
        });
        const marker = L.marker([lat, lng], { icon: icon });
        marker.bindPopup(makePopup(props, order), { maxWidth: 320 });
        return marker;
      }
      createPointLayers(features) {
        this.clearPointLayers();
        const pointsByDay = this.groupPointsByDay(features);
        
        if (pointsByDay.size === 0) {
          console.log("[ROUTES] Aucun point valide trouv√© pour cr√©er les calques de points");
          return;
        }
        
        pointsByDay.forEach((points, day) => {
          const layerGroup = L.layerGroup();
          points.forEach((point) => {
            const feature = features[point.index];
            if (feature) {
              const marker = this.createMarker(feature, point.lat, point.lon, point.order);
              marker.addTo(layerGroup);
            }
          });
          this.pointLayers.set(day, {
            layer: layerGroup,
            day: day,
            pointCount: points.length
          });
        });
        
        console.log("[ROUTES] " + this.pointLayers.size + " calque(s) de points cr√©√©(s)");
      }
      
      createRouteLayers(features) {
        this.clearRouteLayers();
        const pointsByDay = this.groupPointsByDay(features);
        
        if (pointsByDay.size === 0) {
          console.log("[ROUTES] Aucun point valide trouv√© pour cr√©er les trajets");
          return;
        }
        
        pointsByDay.forEach((points, day) => {
          const color = this.dayColors[(day - 1) % this.dayColors.length];
          const layerGroup = L.layerGroup();
          
          for (let i = 0; i < points.length - 1; i++) {
            const point1 = points[i];
            const point2 = points[i + 1];
            const routeLine = this.createRouteLine(point1, point2, color);
            routeLine.addTo(layerGroup);
          }
          
          this.routeLayers.set(day, {
            layer: layerGroup,
            color: color,
            day: day,
            pointCount: points.length
          });
        });
        
        console.log("[ROUTES] " + this.routeLayers.size + " calque(s) de trajet cr√©√©(s)");
      }
      clearPointLayers() {
        this.pointLayers.forEach((pointData, day) => {
          if (this.map.hasLayer(pointData.layer)) {
            this.map.removeLayer(pointData.layer);
          }
        });
        this.pointLayers.clear();
      }
      
      clearRouteLayers() {
        this.routeLayers.forEach((routeData, day) => {
          if (this.map.hasLayer(routeData.layer)) {
            this.map.removeLayer(routeData.layer);
          }
        });
        this.routeLayers.clear();
      }
      addLayerControl(baseLayers, overlayLayers) {
        if (this.layerControl) {
          this.map.removeControl(this.layerControl);
        }
        
        const pointOverlays = {};
        this.pointLayers.forEach((pointData, day) => {
          pointOverlays['Points - Jour ' + day] = pointData.layer;
        });
        
        const routeOverlays = {};
        this.routeLayers.forEach((routeData, day) => {
          routeOverlays['Trajets - Jour ' + day] = routeData.layer;
        });
        
        const allOverlays = Object.assign({}, pointOverlays, routeOverlays, overlayLayers);
        
        this.layerControl = L.control.layers(baseLayers, allOverlays, {
          position: 'topright',
          collapsed: true
        });
        
        this.layerControl.addTo(this.map);
      }
      
      showAllPoints() {
        this.pointLayers.forEach((pointData, day) => {
          if (!this.map.hasLayer(pointData.layer)) {
            pointData.layer.addTo(this.map);
          }
        });
      }
      
      hideAllPoints() {
        this.pointLayers.forEach((pointData, day) => {
          if (this.map.hasLayer(pointData.layer)) {
            this.map.removeLayer(pointData.layer);
          }
        });
      }
      
      showAllRoutes() {
        this.routeLayers.forEach((routeData, day) => {
          if (!this.map.hasLayer(routeData.layer)) {
            routeData.layer.addTo(this.map);
          }
        });
      }
      
      hideAllRoutes() {
        this.routeLayers.forEach((routeData, day) => {
          if (this.map.hasLayer(routeData.layer)) {
            this.map.removeLayer(routeData.layer);
          }
        });
      }
    }
    let routeManager = null;
    
    function initRouteManager(map) {
      if (!routeManager) {
        routeManager = new RouteLayerManager(map);
        console.log("[ROUTES] Gestionnaire de routes initialis√©");
      }
      return routeManager;
    }
    function processRoutes(features) {
      if (!routeManager) {
        if (typeof map !== 'undefined') {
          routeManager = initRouteManager(map);
        } else {
          console.warn("[ROUTES] La carte n'est pas encore initialis√©e");
          return;
        }
      }
      
      const layersToRemove = [];
      map.eachLayer((layer) => {
        if (layer instanceof L.FeatureGroup) {
          const layers = layer.getLayers();
          const hasMarkers = layers.some(l => l instanceof L.Marker);
          if (hasMarkers) {
            layersToRemove.push(layer);
          }
        } else if (layer instanceof L.Marker) {
          layersToRemove.push(layer);
        }
      });
      
      layersToRemove.forEach((layer) => {
        map.removeLayer(layer);
      });
      
      console.log("[ROUTES] " + layersToRemove.length + " groupe(s) de marqueurs supprim√©(s)");
      
      routeManager.createPointLayers(features);
      routeManager.createRouteLayers(features);
      
      const baseLayers = {};
      const overlayLayers = {};
      routeManager.addLayerControl(baseLayers, overlayLayers);
      
      routeManager.showAllPoints();
    }    
    // ============================================================
    // FIN DU MODULE ROUTES
    // ============================================================
    
    function integrateRoutes(features) {
      if (typeof map === 'undefined') {
        console.warn("[ROUTES] La carte n'est pas encore initialis√©e, attente...");
        setTimeout(() => integrateRoutes(features), 100);
        return;
      }
      
      if (!routeManager) {
        routeManager = initRouteManager(map);
      }
      
      processRoutes(features);
    }
    // ============================================================
    // MODULE HOP-ON HOP-OFF - Calque du bus touristique de Rome
    // ============================================================
    // Ce code est compl√®tement ind√©pendant du code principal et des routes
    // Il g√®re uniquement l'affichage du parcours et des arr√™ts du bus hop-on hop-off
        class HopOnHopOffLayerManager {
      constructor(map) {
        this.map = map;
        this.routeLayer = null;
        this.stopMarkers = [];
        this.layerControl = null;
      }
      createRoute() {
        // Coordonn√©es des arr√™ts du bus hop-on hop-off
        const routeCoordinates = [
          [41.9019, 12.5018],
          [41.8902, 12.4922],
          [41.886, 12.4858],
          [41.8884, 12.4819],
          [41.8955, 12.4723],
          [41.8992, 12.4731],
          [41.8986, 12.4768],
          [41.9009, 12.4833],
          [41.906, 12.4823],
          [41.9142, 12.4869],
          [41.9106, 12.4762],
          [41.9065, 12.4534],
          [41.9022, 12.4539],
          [41.9031, 12.4663]
        ];
        
        // Cr√©er la polyline du parcours
        this.routeLayer = L.polyline(routeCoordinates, {
          color: '#ff6b35',
          weight: 5,
          opacity: 0.8,
          className: 'hoponhopoff-route'
        });
        
        // Ajouter un popup au parcours
        const routeInfo = '<div style="text-align: center; padding: 10px;">' +
          '<h3 style="margin: 0 0 10px 0; color: #ff6b35;">üöå Bus Hop-On Hop-Off</h3>' +
          '<p style="margin: 5px 0;"><strong>Parcours touristique de Rome</strong></p>' +
          '<p style="margin: 5px 0; font-size: 0.9em; color: #666;">' +
          '14 arr√™ts principaux</p>' +
          '<p style="margin: 5px 0; font-size: 0.85em; color: #888;">' +
          'Cliquez sur les marqueurs pour voir les arr√™ts</p>' +
          '</div>';
        this.routeLayer.bindPopup(routeInfo);
        
        return this.routeLayer;
      }
      createStops() {
        // Nettoyer les marqueurs existants
        this.clearStops();
        
        // D√©finir les arr√™ts
        const stops = [
          {
            name: "Termini Station",
            lat: 41.9019,
            lon: 12.5018,
            description: "Gare principale de Rome - Point de d√©part principal",
            order: 1,
            note: ""
          },
          {
            name: "Colosseum",
            lat: 41.8902,
            lon: 12.4922,
            description: "Colis√©e - Amphith√©√¢tre Flavien",
            order: 2,
            note: ""
          },
          {
            name: "Circus Maximus",
            lat: 41.886,
            lon: 12.4858,
            description: "Cirque Maxime - Ancien stade romain",
            order: 3,
            note: ""
          },
          {
            name: "Bocca della Verit√†",
            lat: 41.8884,
            lon: 12.4819,
            description: "Bouche de la V√©rit√©",
            order: 4,
            note: ""
          },
          {
            name: "Campo de' Fiori",
            lat: 41.8955,
            lon: 12.4723,
            description: "Campo de\' Fiori - March√© et place historique",
            order: 5,
            note: ""
          },
          {
            name: "Piazza Navona",
            lat: 41.8992,
            lon: 12.4731,
            description: "Place Navone - Place baroque",
            order: 6,
            note: ""
          },
          {
            name: "Pantheon",
            lat: 41.8986,
            lon: 12.4768,
            description: "Panth√©on - Temple romain",
            order: 7,
            note: ""
          },
          {
            name: "Trevi Fountain",
            lat: 41.9009,
            lon: 12.4833,
            description: "Fontaine de Trevi",
            order: 8,
            note: ""
          },
          {
            name: "Spanish Steps",
            lat: 41.906,
            lon: 12.4823,
            description: "Escalier de la Trinit√©-des-Monts",
            order: 9,
            note: ""
          },
          {
            name: "Villa Borghese",
            lat: 41.9142,
            lon: 12.4869,
            description: "Villa Borgh√®se - Parc et mus√©es",
            order: 10,
            note: ""
          },
          {
            name: "Piazza del Popolo",
            lat: 41.9106,
            lon: 12.4762,
            description: "Place du Peuple",
            order: 11,
            note: ""
          },
          {
            name: "Vatican Museums",
            lat: 41.9065,
            lon: 12.4534,
            description: "Mus√©es du Vatican",
            order: 12,
            note: ""
          },
          {
            name: "St. Peter's Basilica",
            lat: 41.9022,
            lon: 12.4539,
            description: "Basilique Saint-Pierre",
            order: 13,
            note: ""
          },
          {
            name: "Castel Sant'Angelo",
            lat: 41.9031,
            lon: 12.4663,
            description: "Ch√¢teau Saint-Ange",
            order: 14,
            note: ""
          }
        ];

        // Cr√©er un marqueur pour chaque arr√™t
        stops.forEach((stop) => {
          // Cr√©er une ic√¥ne personnalis√©e pour les arr√™ts (juste l'ic√¥ne de bus)
          const stopIcon = L.divIcon({
            className: 'hoponhopoff-stop-icon',
            html: '<div class="hoponhopoff-stop-marker" title="Arr√™t ' + stop.order + '"></div>',
            iconSize: [32, 32],
            iconAnchor: [16, 16],
            popupAnchor: [0, -16]
          });
          
          // Cr√©er le marqueur
          const marker = L.marker([stop.lat, stop.lon], { icon: stopIcon });
          
          // Cr√©er le contenu du popup
          const popupContent = '<div style="text-align: center; padding: 8px; min-width: 200px;">' +
            '<div style="color: #ff6b35; font-weight: bold; margin-bottom: 5px;">' +
            'üöå Arr√™t ' + stop.order + '</div>' +
            '<div style="font-size: 1.1em; font-weight: bold; margin-bottom: 5px;">' +
            stop.name + '</div>' +
            (stop.description ? '<div style="font-size: 0.9em; color: #666; margin-top: 5px;">' +
            stop.description + '</div>' : '') +
            (stop.note ? '<div style="font-size: 0.85em; color: #d97706; margin-top: 8px; padding: 5px; background-color: #fef3c7; border-left: 3px solid #d97706; border-radius: 3px;">' +
            '‚ö†Ô∏è ' + stop.note + '</div>' : '') +
            '</div>';
          
          marker.bindPopup(popupContent);
          this.stopMarkers.push(marker);
        });
        
        console.log("[HOPONHOPOFF] " + this.stopMarkers.length + " arr√™t(s) cr√©√©(s)");
        return this.stopMarkers;
      }
      clearRoute() {
        if (this.routeLayer && this.map.hasLayer(this.routeLayer)) {
          this.map.removeLayer(this.routeLayer);
        }
        this.routeLayer = null;
      }
      
      clearStops() {
        this.stopMarkers.forEach((marker) => {
          if (this.map.hasLayer(marker)) {
            this.map.removeLayer(marker);
          }
        });
        this.stopMarkers = [];
      }
      
      clearAll() {
        this.clearRoute();
        this.clearStops();
      }
      showRoute() {
        if (this.routeLayer && !this.map.hasLayer(this.routeLayer)) {
          this.routeLayer.addTo(this.map);
        }
      }
      
      hideRoute() {
        if (this.routeLayer && this.map.hasLayer(this.routeLayer)) {
          this.map.removeLayer(this.routeLayer);
        }
      }
      
      showStops() {
        this.stopMarkers.forEach((marker) => {
          if (!this.map.hasLayer(marker)) {
            marker.addTo(this.map);
          }
        });
      }
      
      hideStops() {
        this.stopMarkers.forEach((marker) => {
          if (this.map.hasLayer(marker)) {
            this.map.removeLayer(marker);
          }
        });
      }
      
      showAll() {
        this.showRoute();
        this.showStops();
      }
      
      hideAll() {
        this.hideRoute();
        this.hideStops();
      }
      addLayerControl(baseLayers, overlayLayers) {
        if (this.layerControl) {
          this.map.removeControl(this.layerControl);
        }
        
        // Cr√©er les calques s√©par√©s : Arr√™ts en premier, puis Parcours
        const stopsLayerGroup = L.layerGroup(this.stopMarkers);
        
        const hoponhopoffOverlays = {
          'Bus Hop-On Hop-Off - Arr√™ts': stopsLayerGroup,
          'Bus Hop-On Hop-Off - Parcours': this.routeLayer
        };
        
        const allOverlays = Object.assign({}, hoponhopoffOverlays, overlayLayers);
        
        this.layerControl = L.control.layers(baseLayers, allOverlays, {
          position: 'topright',
          collapsed: true
        });
        
        this.layerControl.addTo(this.map);
      }
    }
    let hopOnHopOffManager = null;
    
    function initHopOnHopOffManager(map) {
      if (!hopOnHopOffManager) {
        hopOnHopOffManager = new HopOnHopOffLayerManager(map);
        console.log("[HOPONHOPOFF] Gestionnaire hop-on hop-off initialis√©");
      }
      return hopOnHopOffManager;
    }
    function processHopOnHopOff() {
      // V√©rifier que map existe avant d'essayer de l'utiliser
      if (typeof map === 'undefined') {
        console.warn("[HOPONHOPOFF] La carte n'est pas encore initialis√©e");
        return;
      }
      
      if (!hopOnHopOffManager) {
        hopOnHopOffManager = initHopOnHopOffManager(map);
      }
      
      // Cr√©er le parcours et les arr√™ts (mais ne pas les afficher par d√©faut)
      hopOnHopOffManager.createRoute();
      hopOnHopOffManager.createStops();
      
      // Ne pas afficher par d√©faut - les cases seront non coch√©es dans le contr√¥le de calques
      // L'utilisateur devra cocher les cases pour afficher les arr√™ts ou le parcours
      
      // Ajouter au contr√¥le de calques (Arr√™ts en premier, Parcours en dessous)
      const baseLayers = {};
      const overlayLayers = {};
      hopOnHopOffManager.addLayerControl(baseLayers, overlayLayers);
      
      console.log("[HOPONHOPOFF] Calque hop-on hop-off cr√©√© (masqu√© par d√©faut)");
    }    
    // ============================================================
    // FIN DU MODULE HOP-ON HOP-OFF
    // ============================================================
    
    // Int√©gration du calque hop-on hop-off
    function integrateHopOnHopOff() {
      if (typeof map === 'undefined') {
        console.warn("[HOPONHOPOFF] La carte n'est pas encore initialis√©e, attente...");
        setTimeout(() => integrateHopOnHopOff(), 100);
        return;
      }
      
      if (!hopOnHopOffManager) {
        hopOnHopOffManager = initHopOnHopOffManager(map);
      }
      
      processHopOnHopOff();
    }

    // ‚úÖ URL du fichier GeoJSON sur GitHub
    const GEOJSON_URL = "https://raw.githubusercontent.com/Sinnamary/Rome/main/attractions_rome_2026-01-06.geojson";

    // D√©clarer map dans le scope global pour √©viter les erreurs de r√©f√©rence
    let map;
    
    // Initialiser la carte
    map = L.map('map', { zoomControl: true });

    // Fond de carte (OpenStreetMap)
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    function esc(s){
      return String(s ?? '').replace(/[&<>"']/g, (c)=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c]));
    }

    function prioClass(prio){
      const p = String(prio ?? '').toLowerCase().trim();
      if (p === 'haute') return { cls: 'prio-haute', badge: 'badge-haute' };
      if (p === 'moyenne') return { cls: 'prio-moyenne', badge: 'badge-moyenne' };
      if (p === 'basse') return { cls: 'prio-basse', badge: 'badge-basse' };
      return { cls: 'prio-defaut', badge: 'badge-defaut' };
    }

    function formatReservation(v){
      if (v === true || String(v).toLowerCase() === 'true') return 'Oui';
      if (v === false || String(v).toLowerCase() === 'false') return 'Non';
      return esc(v);
    }

    function formatDateFrench(dateStr){
      if (!dateStr) return '';
      // Convertir YYYY-MM-DD en DD/MM/YYYY
      const parts = dateStr.split('-');
      if (parts.length === 3) {
        return parts[2] + '/' + parts[1] + '/' + parts[0];
      }
      return dateStr;
    }

    function formatDateFullFrench(dateStr, jourStr){
      if (!dateStr) return '';
      
      const joursSemaine = ['Dimanche', 'Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi'];
      const mois = ['janvier', 'f√©vrier', 'mars', 'avril', 'mai', 'juin', 'juillet', 'ao√ªt', 'septembre', 'octobre', 'novembre', 'd√©cembre'];
      
      try {
        const parts = dateStr.split('-');
        if (parts.length === 3) {
          const year = parseInt(parts[0], 10);
          const month = parseInt(parts[1], 10) - 1; // 0-indexed
          const day = parseInt(parts[2], 10);
          
          const date = new Date(year, month, day);
          const jourIndex = date.getDay();
          const jourNom = joursSemaine[jourIndex];
          const moisNom = mois[month];
          
          return jourNom + ' ' + day + ' ' + moisNom + ' ' + year;
        }
      } catch (e) {
        // En cas d'erreur, utiliser le format simple
        if (jourStr) {
          const parts = dateStr.split('-');
          if (parts.length === 3) {
            const mois = ['janvier', 'f√©vrier', 'mars', 'avril', 'mai', 'juin', 'juillet', 'ao√ªt', 'septembre', 'octobre', 'novembre', 'd√©cembre'];
            const month = parseInt(parts[1], 10) - 1;
            return jourStr + ' ' + parts[2] + ' ' + mois[month] + ' ' + parts[0];
          }
        }
      }
      return dateStr;
    }

    function formatDureeMinutes(dureeStr){
      if (!dureeStr) return '';
      
      try {
        // Format attendu : "H:MM" ou "HH:MM" (ex: "0:45", "2:00", "1:30")
        const parts = String(dureeStr).split(':');
        if (parts.length >= 2) {
          const hours = parseInt(parts[0], 10) || 0;
          const minutes = parseInt(parts[1], 10) || 0;
          const totalMinutes = hours * 60 + minutes;
          
          if (totalMinutes === 0) return '';
          if (totalMinutes === 1) return '1 minute';
          return totalMinutes + ' minutes';
        }
      } catch (e) {
        // En cas d'erreur, retourner la valeur originale
      }
      return dureeStr;
    }

    function makePopup(props, num){
      const name = props.name ?? `Visite ${num}`;
      const date = props.date ?? '';
      const jour = props.jour ?? '';
      const debut = props.heure_debut ?? '';
      const fin = props.heure_fin ?? '';
      const duree = props.duree ?? '';
      const prix = (props.prix ?? props.price ?? '');
      const reservation = formatReservation(props.reservation);
      const url = props.url ?? '';
      const description = props.description ?? '';
      const commentaire = props.commentaire ?? '';
      const priorite = props.priorite ?? '';

      const { badge } = prioClass(priorite);

      // Capitaliser la premi√®re lettre pour l'affichage
      const prioriteDisplay = priorite 
        ? priorite.charAt(0).toUpperCase() + priorite.slice(1).toLowerCase()
        : '';

      const badgeHtml = priorite
        ? ` <span class="badge ${badge}">${esc(prioriteDisplay)}</span>`
        : '';

      const horaire = (debut || fin) ? `${esc(debut)}${(debut && fin) ? ' ‚Äì ' : ''}${esc(fin)}` : '';

      const lienUrl = url
        ? `<li>üîó <strong>Lien</strong> : <a href="${esc(url)}" target="_blank" rel="noopener">ouvrir</a></li>`
        : '';

      const commentaireHtml = commentaire
        ? `<li>üí¨ <strong>Commentaire</strong> : ${esc(commentaire)}</li>`
        : '';

      const prixTxt = (prix === 0 || prix === "0") ? "0 ‚Ç¨" : (prix ? `${esc(prix)} ‚Ç¨` : '');

      // Formater la date en format fran√ßais DD/MM/YYYY
      const dateFormatted = formatDateFrench(date);

      // Formater la dur√©e en minutes
      const dureeFormatted = formatDureeMinutes(duree);

      // G√©n√©rer la description "Visite pr√©vue le..." en format fran√ßais complet
      let visitePrevue = '';
      if (date) {
        const dateFullFrench = formatDateFullFrench(date, jour);
        if (dateFullFrench) {
          visitePrevue = 'Visite pr√©vue le ' + dateFullFrench;
          if (horaire) {
            visitePrevue += ' de ' + horaire;
          }
        }
      }

      return `
        <div class="popup">
          <h3>${esc(num)}. ${esc(name)}${badgeHtml}</h3>
          <ul class="meta">
            ${dateFormatted ? `<li>üìÖ <strong>Date</strong> : ${esc(dateFormatted)}</li>` : ''}
            ${horaire ? `<li>‚è∞ <strong>Horaire</strong> : ${esc(horaire)}</li>` : ''}
            ${dureeFormatted ? `<li>‚è± <strong>Dur√©e</strong> : ${esc(dureeFormatted)}</li>` : ''}
            ${prixTxt ? `<li>üí∂ <strong>Prix</strong> : ${prixTxt}</li>` : ''}
            ${(props.reservation !== undefined && props.reservation !== null) ? `<li>üìû <strong>R√©servation</strong> : ${esc(reservation)}</li>` : ''}
            ${lienUrl}
            ${commentaireHtml}
          </ul>
          ${visitePrevue ? `<p class="muted" style="margin:8px 0 0 0;">${esc(visitePrevue)}</p>` : (description ? `<p class="muted" style="margin:8px 0 0 0;">${esc(description)}</p>` : '')}
        </div>
      `;
    }

    async function loadGeoJson(){
      const res = await fetch(GEOJSON_URL, { cache: 'no-store' });
      if (!res.ok) throw new Error(`Impossible de charger le GeoJSON (${res.status})`);
      const gj = await res.json();
      processGeoJSON(gj);
    function integrateRoutes(features) {
      if (typeof map === 'undefined') {
        console.warn("[ROUTES] La carte n'est pas encore initialis√©e, attente...");
        setTimeout(() => integrateRoutes(features), 100);
        return;
      }
      
      if (!routeManager) {
        routeManager = initRouteManager(map);
      }
      
      processRoutes(features);
    }
      // Int√©grer les routes apr√®s traitement du GeoJSON
      if (typeof integrateRoutes === 'function') {
        integrateRoutes(gj.features || []);
      }
      // Int√©grer le calque hop-on hop-off apr√®s traitement du GeoJSON
      if (typeof integrateHopOnHopOff === 'function') {
        integrateHopOnHopOff();
      }
    }
    
    function processGeoJSON(gj) {
      // Num√©rotation: si props.ordre / props.numero / props.visite existent => on les utilise, sinon index + 1
      const features = (gj.features ?? []).map((f, i) => {
        const p = f.properties ?? {};
        // Convertir en cha√Æne pour garantir la coh√©rence
        const num = String(p.ordre ?? p.numero ?? p.visite ?? p.id ?? (i + 1));
        return { f, num, i };
      });

      // S√©parer les points d'h√©bergement (ordre 0.0) des autres points
      const hebergementFeatures = [];
      const normalFeatures = [];
      
      features.forEach(function(item) {
        const num = item.num;
        // D√©tecter l'ordre 0.0 (h√©bergement)
        if (num === '0.0' || num === '0' || parseFloat(num) === 0.0) {
          hebergementFeatures.push(item);
        } else {
          normalFeatures.push(item);
        }
      });

      // D√©tecter et g√©rer les points superpos√©s (m√™mes coordonn√©es) pour les points normaux
      const coordMap = new Map();
      const offsetNormalFeatures = normalFeatures.map(function(item) {
        const f = item.f;
        const num = item.num;
        const i = item.i;
        const coords = f.geometry && f.geometry.type === 'Point' ? f.geometry.coordinates : null;
        if (!coords) return { f: f, num: num, i: i, lat: null, lng: null };
        const lng = coords[0];
        const lat = coords[1];
        const coordKey = lat.toFixed(6) + ',' + lng.toFixed(6);
        
        // Compter combien de points ont ces coordonn√©es
        const count = coordMap.get(coordKey) || 0;
        coordMap.set(coordKey, count + 1);
        
        // Si plusieurs points ont les m√™mes coordonn√©es, les d√©caler l√©g√®rement
        let offsetLat = lat;
        let offsetLng = lng;
        if (count > 0) {
          // D√©calage en spirale : chaque point est d√©cal√© de ~50m
          const angle = (count * 60) * (Math.PI / 180); // 60 degr√©s entre chaque point
          const offset = 0.0005 * count; // ~50m par niveau
          offsetLat = lat + offset * Math.cos(angle);
          offsetLng = lng + offset * Math.sin(angle);
        }
        
        return { f: f, num: num, i: i, lat: offsetLat, lng: offsetLng, originalLat: lat, originalLng: lng };
      });

      // Regrouper les h√©bergements (ordre 0.0) en un seul point unique
      const hebergementMap = new Map();
      hebergementFeatures.forEach(function(item) {
        const f = item.f;
        const coords = f.geometry && f.geometry.type === 'Point' ? f.geometry.coordinates : null;
        if (!coords) return;
        const lng = coords[0];
        const lat = coords[1];
        const coordKey = lat.toFixed(6) + ',' + lng.toFixed(6);
        
        // Regrouper par coordonn√©es (un seul point d'h√©bergement par emplacement)
        if (!hebergementMap.has(coordKey)) {
          // Prendre la premi√®re feature trouv√©e pour cet emplacement
          hebergementMap.set(coordKey, {
            f: f,
            lat: lat,
            lng: lng,
            props: f.properties || {}
          });
        }
      });

      const group = L.featureGroup();

      // Ajouter les points normaux
      offsetNormalFeatures.forEach(function(item) {
        const f = item.f;
        const num = item.num;
        const lat = item.lat;
        const lng = item.lng;
        if (lat === null || lng === null) return;
        
        const props = f.properties || {};
        const priorite = props.priorite || '';
        const prioInfo = prioClass(priorite);
        const cls = prioInfo.cls;

        const iconHtml = '<div class="num-marker ' + cls + '">' + esc(num) + '</div>';
        const icon = L.divIcon({
          className: '',
          html: iconHtml,
          iconSize: [32, 32],
          iconAnchor: [16, 32],  // anchor bottom middle
          popupAnchor: [0, -28]
        });

        const marker = L.marker([lat, lng], { icon: icon });
        marker.bindPopup(makePopup(props, num), { maxWidth: 320 });
        marker.addTo(group);
      });

      // Ajouter les points d'h√©bergement (un seul par emplacement)
      hebergementMap.forEach(function(hebergement) {
        const props = hebergement.props;
        const lat = hebergement.lat;
        const lng = hebergement.lng;
        
        // Ic√¥ne d'habitation pour l'h√©bergement
        const iconHtml = '<div class="hebergement-marker">üè†</div>';
        const icon = L.divIcon({
          className: '',
          html: iconHtml,
          iconSize: [40, 40],
          iconAnchor: [20, 40],  // anchor bottom middle
          popupAnchor: [0, -35]
        });

        const marker = L.marker([lat, lng], { icon: icon });
        marker.bindPopup(makePopup(props, '0.0'), { maxWidth: 320 });
        marker.addTo(group);
      });
      

      group.addTo(map);

      // Zoom sur l'ensemble des points (avec marge)
      const b = group.getBounds();
      if (b.isValid()) {
        map.fitBounds(b.pad(0.15));
        
        // V√©rifier la visibilit√© des points prioritaires apr√®s le zoom
        if (typeof priorityMarkers !== 'undefined' && priorityMarkers.length > 0) {
          priorityMarkers.forEach(function(marker) {
            const markerBounds = L.latLngBounds([marker.getLatLng()]);
            const isVisible = b.contains(markerBounds);
            if (!isVisible) {
              // Centrer la carte sur le point prioritaire si n√©cessaire
              map.setView(marker.getLatLng(), 15);
            }
          });
        }
      } else {
        map.setView([41.9028, 12.4964], 12); // Rome fallback
      }
    }

    loadGeoJson().catch(err => {
      console.error(err);
      alert("Erreur : " + err.message);
      map.setView([41.9028, 12.4964], 12);
    });
  </script>
</body>
</html>