<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Rome 2026 ‚Äî Visites (GeoJSON)</title>
  <link rel="icon" type="image/svg+xml" href="favicon.svg" />

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
          integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; width: 100%; }

    /* Numbered circle marker (DivIcon) */
    .num-marker{
      width: 32px; height: 32px;
      border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
      font: 700 14px/1 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: #fff;
      border: 2px solid rgba(255,255,255,0.9);
      box-shadow: 0 2px 8px rgba(0,0,0,0.35);
    }
    .prio-haute { background: #c62828; }
    .prio-moyenne { background: #ef6c00; }
    .prio-basse { background: #2e7d32; }
    .prio-defaut { background: #0d47a1; }

    /* Popup layout */
    .popup h3 { margin: 0 0 6px 0; font-size: 16px; }
    .popup .meta { margin: 0; padding: 0; list-style: none; }
    .popup .meta li { margin: 2px 0; }
    .badge {
      display: inline-block; padding: 2px 8px; border-radius: 999px;
      font-size: 12px; font-weight: 600; color: #fff; vertical-align: middle;
    }
    .badge-haute { background:#c62828; }
    .badge-moyenne { background:#ef6c00; }
    .badge-basse { background:#2e7d32; }
    .badge-defaut { background:#0d47a1; }
    .muted { color: #555; }
    .popup a { word-break: break-all; }
  </style>
</head>
<body>
  <div id="map"></div>

  <script>
    // ‚úÖ URL du fichier GeoJSON sur GitHub
    const GEOJSON_URL = "https://raw.githubusercontent.com/Sinnamary/Rome/main/attractions_rome_2026-01-02.geojson";

    const map = L.map('map', { zoomControl: true });

    // Fond de carte (OpenStreetMap)
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    function esc(s){
      return String(s ?? '').replace(/[&<>"']/g, (c)=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c]));
    }

    function prioClass(prio){
      const p = String(prio ?? '').toLowerCase().trim();
      if (p === 'haute') return { cls: 'prio-haute', badge: 'badge-haute' };
      if (p === 'moyenne') return { cls: 'prio-moyenne', badge: 'badge-moyenne' };
      if (p === 'basse') return { cls: 'prio-basse', badge: 'badge-basse' };
      return { cls: 'prio-defaut', badge: 'badge-defaut' };
    }

    function formatReservation(v){
      if (v === true || String(v).toLowerCase() === 'true') return 'Oui';
      if (v === false || String(v).toLowerCase() === 'false') return 'Non';
      return esc(v);
    }

    function makePopup(props, num){
      const name = props.name ?? `Visite ${num}`;
      const date = props.date ?? '';
      const debut = props.heure_debut ?? '';
      const fin = props.heure_fin ?? '';
      const duree = props.duree ?? '';
      const prix = (props.prix ?? props.price ?? '');
      const reservation = formatReservation(props.reservation);
      const url = props.url ?? '';
      const description = props.description ?? '';
      const priorite = props.priorite ?? '';

      const { badge } = prioClass(priorite);

      // Capitaliser la premi√®re lettre pour l'affichage
      const prioriteDisplay = priorite 
        ? priorite.charAt(0).toUpperCase() + priorite.slice(1).toLowerCase()
        : '';

      const badgeHtml = priorite
        ? ` <span class="badge ${badge}">${esc(prioriteDisplay)}</span>`
        : '';

      const horaire = (debut || fin) ? `${esc(debut)}${(debut && fin) ? ' ‚Äì ' : ''}${esc(fin)}` : '';

      const lienUrl = url
        ? `<li>üîó <strong>Lien</strong> : <a href="${esc(url)}" target="_blank" rel="noopener">ouvrir</a></li>`
        : '';

      const prixTxt = (prix === 0 || prix === "0") ? "0 ‚Ç¨" : (prix ? `${esc(prix)} ‚Ç¨` : '');

      return `
        <div class="popup">
          <h3>${esc(num)}. ${esc(name)}${badgeHtml}</h3>
          <ul class="meta">
            ${date ? `<li>üìÖ <strong>Date</strong> : ${esc(date)}</li>` : ''}
            ${horaire ? `<li>‚è∞ <strong>Horaire</strong> : ${esc(horaire)}</li>` : ''}
            ${duree ? `<li>‚è± <strong>Dur√©e</strong> : ${esc(duree)}</li>` : ''}
            ${prixTxt ? `<li>üí∂ <strong>Prix</strong> : ${prixTxt}</li>` : ''}
            ${(props.reservation !== undefined && props.reservation !== null) ? `<li>üìû <strong>R√©servation</strong> : ${esc(reservation)}</li>` : ''}
            ${lienUrl}
          </ul>
          ${description ? `<p class="muted" style="margin:8px 0 0 0;">${esc(description)}</p>` : ''}
        </div>
      `;
    }

    async function loadGeoJson(){
      const res = await fetch(GEOJSON_URL, { cache: 'no-store' });
      if (!res.ok) throw new Error(`Impossible de charger le GeoJSON (${res.status})`);
      const gj = await res.json();
      processGeoJSON(gj);
    }
    
    function processGeoJSON(gj) {
      // Num√©rotation: si props.ordre / props.numero / props.visite existent => on les utilise, sinon index + 1
      const features = (gj.features ?? []).map((f, i) => {
        const p = f.properties ?? {};
        // Convertir en cha√Æne pour garantir la coh√©rence
        const num = String(p.ordre ?? p.numero ?? p.visite ?? p.id ?? (i + 1));
        return { f, num, i };
      });

      // D√©tecter et g√©rer les points superpos√©s (m√™mes coordonn√©es)
      const coordMap = new Map();
      const offsetFeatures = features.map(function(item) {
        const f = item.f;
        const num = item.num;
        const i = item.i;
        const coords = f.geometry && f.geometry.type === 'Point' ? f.geometry.coordinates : null;
        if (!coords) return { f: f, num: num, i: i, lat: null, lng: null };
        const lng = coords[0];
        const lat = coords[1];
        const coordKey = lat.toFixed(6) + ',' + lng.toFixed(6);
        
        // Compter combien de points ont ces coordonn√©es
        const count = coordMap.get(coordKey) || 0;
        coordMap.set(coordKey, count + 1);
        
        // Si plusieurs points ont les m√™mes coordonn√©es, les d√©caler l√©g√®rement
        let offsetLat = lat;
        let offsetLng = lng;
        if (count > 0) {
          // D√©calage en spirale : chaque point est d√©cal√© de ~50m
          const angle = (count * 60) * (Math.PI / 180); // 60 degr√©s entre chaque point
          const offset = 0.0005 * count; // ~50m par niveau
          offsetLat = lat + offset * Math.cos(angle);
          offsetLng = lng + offset * Math.sin(angle);
        }
        
        return { f: f, num: num, i: i, lat: offsetLat, lng: offsetLng, originalLat: lat, originalLng: lng };
      });

      const group = L.featureGroup();

      offsetFeatures.forEach(function(item) {
        const f = item.f;
        const num = item.num;
        const lat = item.lat;
        const lng = item.lng;
        if (lat === null || lng === null) return;
        
        const props = f.properties || {};
        const priorite = props.priorite || '';
        const prioInfo = prioClass(priorite);
        const cls = prioInfo.cls;

        const iconHtml = '<div class="num-marker ' + cls + '">' + esc(num) + '</div>';
        const icon = L.divIcon({
          className: '',
          html: iconHtml,
          iconSize: [32, 32],
          iconAnchor: [16, 32],  // anchor bottom middle
          popupAnchor: [0, -28]
        });

        const marker = L.marker([lat, lng], { icon: icon });
        marker.bindPopup(makePopup(props, num), { maxWidth: 320 });
        marker.addTo(group);
      });
      
      // V√©rifier sp√©cifiquement le point 2.2 pour s'assurer qu'il est visible
      const marker22 = group.getLayers().find(layer => {
        if (layer instanceof L.Marker) {
          const popup = layer.getPopup();
          if (popup) {
            const content = popup.getContent();
            return content && content.includes('2.2');
          }
        }
        return false;
      });
      
      if (marker22) {
        // Forcer le point 2.2 √† √™tre visible
        marker22.setZIndexOffset(1000);
      }

      group.addTo(map);

      // Zoom sur l'ensemble des points (avec marge)
      const b = group.getBounds();
      if (b.isValid()) {
        map.fitBounds(b.pad(0.15));
        
        // V√©rifier si le point 2.2 est dans les bounds
        if (marker22) {
          const bounds22 = L.latLngBounds([marker22.getLatLng()]);
          const isVisible = b.contains(bounds22);
          if (!isVisible) {
            // Centrer la carte sur le point 2.2 si n√©cessaire
            map.setView(marker22.getLatLng(), 15);
          }
        }
      } else {
        map.setView([41.9028, 12.4964], 12); // Rome fallback
      }
    }

    loadGeoJson().catch(err => {
      console.error(err);
      alert("Erreur : " + err.message);
      map.setView([41.9028, 12.4964], 12);
    });
  </script>
</body>
</html>