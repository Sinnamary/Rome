<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Rome 2026</title>
  <link rel="icon" type="image/svg+xml" href="favicon.svg" />

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
  <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"
          integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; width: 100%; }

    /* Numbered circle marker (DivIcon) */
    .num-marker{
      width: 32px; height: 32px;
      border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
      font: 700 14px/1 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: #fff;
      border: 2px solid rgba(255,255,255,0.9);
      box-shadow: 0 2px 8px rgba(0,0,0,0.35);
    }
    .prio-haute { background: #c62828; }
    .prio-moyenne { background: #ef6c00; }
    .prio-basse { background: #2e7d32; }
    .prio-defaut { background: #0d47a1; }

    /* H√©bergement marker (ordre 0.0) */
    .hebergement-marker{
      width: 40px; height: 40px;
      border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
      font-size: 24px;
      background: #1e3a8a;
      border: 3px solid rgba(255,255,255,0.95);
      box-shadow: 0 3px 10px rgba(0,0,0,0.4);
    }

    /* Popup layout */
    .popup h3 { margin: 0 0 6px 0; font-size: 16px; }
    .popup .meta { margin: 0; padding: 0; list-style: none; }
    .popup .meta li { margin: 2px 0; }
    .badge {
      display: inline-block; padding: 2px 8px; border-radius: 999px;
      font-size: 12px; font-weight: 600; color: #fff; vertical-align: middle;
    }
    .badge-haute { background:#c62828; }
    .badge-moyenne { background:#ef6c00; }
    .badge-basse { background:#2e7d32; }
    .badge-defaut { background:#0d47a1; }
    .muted { color: #555; }
    .popup a { word-break: break-all; }
    
    /* Styles pour les miniatures de calques Leaflet */
    .leaflet-control-layers-base label {
      display: flex;
      align-items: center;
      padding: 4px 8px;
      cursor: pointer;
    }
    
    .leaflet-control-layers-base label:hover {
      background-color: #f0f0f0;
    }
    
    .leaflet-control-layers-selector {
      margin-right: 8px;
    }
    
    /* S'assurer que les miniatures sont visibles */
    .leaflet-control-layers-base img {
      display: inline-block;
      width: 24px;
      height: 24px;
      margin-right: 8px;
      border: 1px solid #ccc;
      border-radius: 2px;
    }



  </style>
</head>
<body>
  <div id="map"></div>

  <script>
    console.log('[DEBUG] ========================================');
    console.log('[DEBUG] Script de pr√©visualisation charg√©');
    console.log('[DEBUG] ========================================');
    console.log('[DEBUG] V√©rification de Leaflet avant chargement des scripts...');
    console.log('[DEBUG] typeof L:', typeof L);
    




    console.log('[DEBUG] Scripts de calques charg√©s');
    console.log('[DEBUG] typeof L apr√®s chargement des scripts:', typeof L);

    // ‚úÖ URL du fichier GeoJSON sur GitHub
    const GEOJSON_URL = "https://raw.githubusercontent.com/Sinnamary/Rome/main/attractions_rome_2026-02-09.geojson";

    // D√©clarer map dans le scope global pour √©viter les erreurs de r√©f√©rence
    let map;
    
    console.log('[DEBUG] Initialisation de la carte...');
    console.log('[DEBUG] V√©rification de Leaflet:', typeof L);
    
    if (typeof L === 'undefined') {
      console.error('[DEBUG] ERREUR: Leaflet (L) n\'est pas d√©fini!');
    } else {
      console.log('[DEBUG] Leaflet est disponible, version:', L.version || 'inconnue');
    }
    
    // Initialiser la carte
    try {
      console.log('[DEBUG] Cr√©ation de la carte Leaflet...');
      map = L.map('map', { zoomControl: true });
      console.log('[DEBUG] Carte cr√©√©e avec succ√®s:', map);
    } catch (e) {
      console.error('[DEBUG] ERREUR lors de la cr√©ation de la carte:', e);
    }

    // Fond de carte (OpenStreetMap)
    try {
      console.log('[DEBUG] Ajout de la couche de tuiles OpenStreetMap...');
      const tileUrlTemplate = 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';
      console.log('[DEBUG] Template URL des tuiles:', tileUrlTemplate);
      
      const tileLayer = L.tileLayer(tileUrlTemplate, {
        maxZoom: 19,
        attribution: '&copy; OpenStreetMap contributors',
        // Options pour le d√©bogage
        crossOrigin: true
      });
      console.log('[DEBUG] Couche de tuiles cr√©√©e:', tileLayer);
      
      tileLayer.addTo(map);
      console.log('[DEBUG] Couche de tuiles ajout√©e √† la carte');
      
      // D√©finir la vue initiale pour d√©clencher le chargement des tuiles
      if (map) {
        console.log('[DEBUG] D√©finition de la vue initiale de la carte...');
        map.setView([41.9028, 12.4964], 12);
        console.log('[DEBUG] Vue initiale d√©finie, zoom:', map.getZoom(), 'center:', map.getCenter());
      }
      
      // √âcouter les √©v√©nements de chargement des tuiles
      tileLayer.on('tileload', function(e) {
        console.log('[DEBUG] ‚úì Tuile charg√©e avec succ√®s:', e.url);
      });
      
      tileLayer.on('tileerror', function(e, tile) {
        const tileUrl = e.url || (tile && tile.src) || (tile && tile.getAttribute && tile.getAttribute('src')) || 'URL inconnue';
        console.error('[DEBUG] ‚úó ERREUR lors du chargement de la tuile');
        console.error('[DEBUG]   URL de la tuile:', tileUrl);
        console.error('[DEBUG]   Type d\'√©v√©nement:', typeof e);
        console.error('[DEBUG]   Objet e:', e);
        console.error('[DEBUG]   Objet tile:', tile);
        if (e && e.error) {
          console.error('[DEBUG]   Message d\'erreur:', e.error.message);
          console.error('[DEBUG]   Stack trace:', e.error.stack);
        }
        // Afficher plus d'informations sur l'erreur
        if (tile && tile.onerror) {
          console.error('[DEBUG]   Tile a un gestionnaire onerror');
        }
      });
      
      tileLayer.on('loading', function() {
        console.log('[DEBUG] Chargement des tuiles en cours...');
      });
      
      tileLayer.on('load', function() {
        console.log('[DEBUG] ‚úì Toutes les tuiles sont charg√©es');
      });
      
      // V√©rifier l'√©tat apr√®s un court d√©lai
      setTimeout(function() {
        console.log('[DEBUG] V√©rification de l\'√©tat des tuiles apr√®s 2 secondes...');
        const tiles = map._panes && map._panes.tilePane ? map._panes.tilePane.querySelectorAll('img') : [];
        console.log('[DEBUG] Nombre de tuiles dans le DOM:', tiles.length);
        tiles.forEach(function(img, index) {
          console.log('[DEBUG] Tuile', index, ':', img.src, 'loaded:', img.complete, 'naturalWidth:', img.naturalWidth);
          if (!img.complete || img.naturalWidth === 0) {
            console.error('[DEBUG]   ‚úó Tuile', index, 'non charg√©e correctement');
            img.onerror = function() {
              console.error('[DEBUG]   ‚úó Erreur onerror sur tuile', index, ':', img.src);
            };
          }
        });
      }, 2000);
      
    } catch (e) {
      console.error('[DEBUG] ERREUR lors de l\'ajout de la couche de tuiles:', e);
      console.error('[DEBUG] Stack trace:', e.stack);
    }

    function esc(s){
      return String(s ?? '').replace(/[&<>"']/g, (c)=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c]));
    }

    function prioClass(prio){
      const p = String(prio ?? '').toLowerCase().trim();
      if (p === 'haute') return { cls: 'prio-haute', badge: 'badge-haute' };
      if (p === 'moyenne') return { cls: 'prio-moyenne', badge: 'badge-moyenne' };
      if (p === 'basse') return { cls: 'prio-basse', badge: 'badge-basse' };
      return { cls: 'prio-defaut', badge: 'badge-defaut' };
    }

    function formatReservation(v){
      if (v === true || String(v).toLowerCase() === 'true') return 'Oui';
      if (v === false || String(v).toLowerCase() === 'false') return 'Non';
      return esc(v);
    }

    function formatDateFrench(dateStr){
      if (!dateStr) return '';
      // Convertir YYYY-MM-DD en DD/MM/YYYY
      const parts = dateStr.split('-');
      if (parts.length === 3) {
        return parts[2] + '/' + parts[1] + '/' + parts[0];
      }
      return dateStr;
    }

    function formatDateFullFrench(dateStr, jourStr){
      if (!dateStr) return '';
      
      const joursSemaine = ['Dimanche', 'Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi'];
      const mois = ['janvier', 'f√©vrier', 'mars', 'avril', 'mai', 'juin', 'juillet', 'ao√ªt', 'septembre', 'octobre', 'novembre', 'd√©cembre'];
      
      try {
        const parts = dateStr.split('-');
        if (parts.length === 3) {
          const year = parseInt(parts[0], 10);
          const month = parseInt(parts[1], 10) - 1; // 0-indexed
          const day = parseInt(parts[2], 10);
          
          const date = new Date(year, month, day);
          const jourIndex = date.getDay();
          const jourNom = joursSemaine[jourIndex];
          const moisNom = mois[month];
          
          return jourNom + ' ' + day + ' ' + moisNom + ' ' + year;
        }
      } catch (e) {
        // En cas d'erreur, utiliser le format simple
        if (jourStr) {
          const parts = dateStr.split('-');
          if (parts.length === 3) {
            const mois = ['janvier', 'f√©vrier', 'mars', 'avril', 'mai', 'juin', 'juillet', 'ao√ªt', 'septembre', 'octobre', 'novembre', 'd√©cembre'];
            const month = parseInt(parts[1], 10) - 1;
            return jourStr + ' ' + parts[2] + ' ' + mois[month] + ' ' + parts[0];
          }
        }
      }
      return dateStr;
    }

    function formatDureeMinutes(dureeStr){
      if (!dureeStr) return '';
      
      try {
        // Format attendu : "H:MM" ou "HH:MM" (ex: "0:45", "2:00", "1:30")
        const parts = String(dureeStr).split(':');
        if (parts.length >= 2) {
          const hours = parseInt(parts[0], 10) || 0;
          const minutes = parseInt(parts[1], 10) || 0;
          const totalMinutes = hours * 60 + minutes;
          
          if (totalMinutes === 0) return '';
          if (totalMinutes === 1) return '1 minute';
          return totalMinutes + ' minutes';
        }
      } catch (e) {
        // En cas d'erreur, retourner la valeur originale
      }
      return dureeStr;
    }

    function makePopup(props, num){
      const name = props.name ?? `Visite ${num}`;
      const date = props.date ?? '';
      const jour = props.jour ?? '';
      const debut = props.heure_debut ?? '';
      const fin = props.heure_fin ?? '';
      const duree = props.duree ?? '';
      const prix = (props.prix ?? props.price ?? '');
      const reservation = formatReservation(props.reservation);
      const url = props.url ?? '';
      const description = props.description ?? '';
      const commentaire = props.commentaire ?? '';
      const priorite = props.priorite ?? '';

      const { badge } = prioClass(priorite);

      // Capitaliser la premi√®re lettre pour l'affichage
      const prioriteDisplay = priorite 
        ? priorite.charAt(0).toUpperCase() + priorite.slice(1).toLowerCase()
        : '';

      const badgeHtml = priorite
        ? ` <span class="badge ${badge}">${esc(prioriteDisplay)}</span>`
        : '';

      const horaire = (debut || fin) ? `${esc(debut)}${(debut && fin) ? ' ‚Äì ' : ''}${esc(fin)}` : '';

      const lienUrl = url
        ? `<li>üîó <strong>Lien</strong> : <a href="${esc(url)}" target="_blank" rel="noopener">ouvrir</a></li>`
        : '';

      const commentaireHtml = commentaire
        ? `<li>üí¨ <strong>Commentaire</strong> : ${esc(commentaire)}</li>`
        : '';

      const prixTxt = (prix === 0 || prix === "0") ? "0 ‚Ç¨" : (prix ? `${esc(prix)} ‚Ç¨` : '');

      // Formater la date en format fran√ßais DD/MM/YYYY
      const dateFormatted = formatDateFrench(date);

      // Formater la dur√©e en minutes
      const dureeFormatted = formatDureeMinutes(duree);

      // G√©n√©rer la description "Visite pr√©vue le..." en format fran√ßais complet
      let visitePrevue = '';
      if (date) {
        const dateFullFrench = formatDateFullFrench(date, jour);
        if (dateFullFrench) {
          visitePrevue = 'Visite pr√©vue le ' + dateFullFrench;
          if (horaire) {
            visitePrevue += ' de ' + horaire;
          }
        }
      }

      return `
        <div class="popup">
          <h3>${esc(num)}. ${esc(name)}${badgeHtml}</h3>
          <ul class="meta">
            ${dateFormatted ? `<li>üìÖ <strong>Date</strong> : ${esc(dateFormatted)}</li>` : ''}
            ${horaire ? `<li>‚è∞ <strong>Horaire</strong> : ${esc(horaire)}</li>` : ''}
            ${dureeFormatted ? `<li>‚è± <strong>Dur√©e</strong> : ${esc(dureeFormatted)}</li>` : ''}
            ${prixTxt ? `<li>üí∂ <strong>Prix</strong> : ${prixTxt}</li>` : ''}
            ${(props.reservation !== undefined && props.reservation !== null) ? `<li>üìû <strong>R√©servation</strong> : ${esc(reservation)}</li>` : ''}
            ${lienUrl}
            ${commentaireHtml}
          </ul>
          ${visitePrevue ? `<p class="muted" style="margin:8px 0 0 0;">${esc(visitePrevue)}</p>` : (description ? `<p class="muted" style="margin:8px 0 0 0;">${esc(description)}</p>` : '')}
        </div>
      `;
    }

    async function loadGeoJson(){
      const res = await fetch(GEOJSON_URL, { cache: 'no-store' });
      if (!res.ok) throw new Error(`Impossible de charger le GeoJSON (${res.status})`);
      const gj = await res.json();
      processGeoJSON(gj);

    }
    
    function processGeoJSON(gj) {
      // Num√©rotation: si props.ordre / props.numero / props.visite existent => on les utilise, sinon index + 1
      const features = (gj.features ?? []).map((f, i) => {
        const p = f.properties ?? {};
        // Convertir en cha√Æne pour garantir la coh√©rence
        const num = String(p.ordre ?? p.numero ?? p.visite ?? p.id ?? (i + 1));
        return { f, num, i };
      });

      // S√©parer les points d'h√©bergement (ordre 0.0) des autres points
      const hebergementFeatures = [];
      const normalFeatures = [];
      
      features.forEach(function(item) {
        const num = item.num;
        // D√©tecter l'ordre 0.0 (h√©bergement)
        if (num === '0.0' || num === '0' || parseFloat(num) === 0.0) {
          hebergementFeatures.push(item);
        } else {
          normalFeatures.push(item);
        }
      });

      // Fonction pour calculer la distance entre deux points (degr√©s)
      function distanceDegrees(lat1, lng1, lat2, lng2) {
        const dLat = lat2 - lat1;
        const dLng = lng2 - lng1;
        return Math.sqrt(dLat * dLat + dLng * dLng);
      }
      
      // Fonction pour obtenir le score de priorit√© d'un point (plus √©lev√© = plus prioritaire)
      function getPriorityScore(props) {
        const priorite = String(props.priorite || '').toLowerCase().trim();
        let score = 0;
        // Priorit√© : haute=3, moyenne=2, basse=1, d√©faut=0
        if (priorite === 'haute') score = 3;
        else if (priorite === 'moyenne') score = 2;
        else if (priorite === 'basse') score = 1;
        // Pr√©sence d'URL : +1
        const url = props.url;
        if (url !== null && url !== undefined && String(url).trim() !== '') {
          score += 1;
        }
        return score;
      }
      
      // D√©tecter et g√©rer les points proches pour les points normaux
      const proximityThreshold = 0.0005;
      const preferPriority = true;
      const DEBUG_MODE = false; // Logs DEBUG uniquement en version locale
      
      // Pr√©parer les donn√©es avec coordonn√©es
      const featuresWithCoords = normalFeatures.map(function(item) {
        const f = item.f;
        const num = item.num;
        const i = item.i;
        const coords = f.geometry && f.geometry.type === 'Point' ? f.geometry.coordinates : null;
        if (!coords) return { f: f, num: num, i: i, lat: null, lng: null, props: {}, isPreferred: false };
        const lng = coords[0];
        const lat = coords[1];
        const props = f.properties || {};
        return { f: f, num: num, i: i, lat: lat, lng: lng, originalLat: lat, originalLng: lng, props: props, isPreferred: false };
      }).filter(function(item) { return item.lat !== null && item.lng !== null; });
      
      // Grouper les points par proximit√©
      const processedFeatures = [];
      const processedIndices = new Set();
      
      for (let i = 0; i < featuresWithCoords.length; i++) {
        if (processedIndices.has(i)) continue;
        
        const current = featuresWithCoords[i];
        const closePoints = [current];
        
        // Trouver tous les points proches de celui-ci
        for (let j = i + 1; j < featuresWithCoords.length; j++) {
          if (processedIndices.has(j)) continue;
          
          const other = featuresWithCoords[j];
          const dist = distanceDegrees(current.lat, current.lng, other.lat, other.lng);
          
          if (dist <= proximityThreshold) {
            closePoints.push(other);
          }
        }
        
        // Si un seul point, pas de d√©calage n√©cessaire
        if (closePoints.length === 1) {
          current.isPreferred = false; // Point isol√©, pas de priorisation n√©cessaire
          processedFeatures.push(current);
          processedIndices.add(current.i);
        } else {
          // Plusieurs points proches : d√©terminer lequel privil√©gier
          if (DEBUG_MODE) {
            console.log(`[DEBUG] Groupe de ${closePoints.length} points proches d√©tect√© (distance < ${proximityThreshold}) : ${closePoints.map(p => p.num).join(', ')}`);
          }
          let preferredIndex = 0;
          
          if (preferPriority) {
            // Trier par score de priorit√© d√©croissant, puis par index croissant
            if (DEBUG_MODE) {
              closePoints.forEach(function(p) {
                const score = getPriorityScore(p.props);
                const priorite = p.props.priorite || 'd√©faut';
                const hasUrl = p.props.url && String(p.props.url).trim() !== '';
                console.log(`[DEBUG] Point ${p.num} (index ${p.i}) - Priorit√©: ${priorite}, Score: ${score}, URL: ${hasUrl ? 'oui' : 'non'}`);
              });
            }
            
            closePoints.sort(function(a, b) {
              const scoreA = getPriorityScore(a.props);
              const scoreB = getPriorityScore(b.props);
              if (scoreB !== scoreA) return scoreB - scoreA; // Plus haut score en premier
              return a.i - b.i; // Si √©gal, premier dans le fichier
            });
            preferredIndex = 0; // Le premier apr√®s tri est le privil√©gi√©
            
            const preferred = closePoints[preferredIndex];
            if (DEBUG_MODE) {
              console.log(`[DEBUG] Point privil√©gi√©: ${preferred.num} (index ${preferred.i}) - Score: ${getPriorityScore(preferred.props)}`);
              closePoints.forEach(function(p, idx) {
                if (idx !== preferredIndex) {
                  console.log(`[DEBUG] Point ${p.num} (index ${p.i}) sera d√©cal√© car moins prioritaire que ${preferred.num}`);
                }
              });
            }
          }
          
          // Le point privil√©gi√© garde ses coordonn√©es originales
          const preferred = closePoints[preferredIndex];
          preferred.isPreferred = true; // Marquer comme privil√©gi√©
          processedFeatures.push(preferred);
          processedIndices.add(preferred.i);
          
          // Les autres points sont d√©cal√©s en spirale
          let offsetCount = 1;
          for (let k = 0; k < closePoints.length; k++) {
            if (k === preferredIndex) continue;
            
            const point = closePoints[k];
            // D√©calage en spirale : chaque point est d√©cal√© de ~50m
            const angle = (offsetCount * 60) * (Math.PI / 180); // 60 degr√©s entre chaque point
            const offset = 0.0005 * offsetCount; // ~50m par niveau
            point.lat = point.originalLat + offset * Math.cos(angle);
            point.lng = point.originalLng + offset * Math.sin(angle);
            point.isPreferred = false; // Marquer comme non privil√©gi√© (d√©cal√©)
            
            processedFeatures.push(point);
            processedIndices.add(point.i);
            offsetCount++;
          }
        }
      }
      
      // Reconstruire avec les points, en s√©parant privil√©gi√©s et d√©cal√©s
      const offsetNormalFeatures = [];
      const preferredFeatures = [];
      
      normalFeatures.forEach(function(item) {
        const processed = processedFeatures.find(function(p) { return p.i === item.i; });
        let featureData = processed ? {
          f: processed.f,
          num: processed.num,
          i: processed.i,
          lat: processed.lat,
          lng: processed.lng,
          originalLat: processed.originalLat,
          originalLng: processed.originalLng,
          isPreferred: processed.isPreferred === true // Utiliser la propri√©t√© marqu√©e lors du traitement
        } : null;
        
        if (!featureData) {
          // Si non trouv√© (point sans coordonn√©es), retourner tel quel
          const coords = item.f.geometry && item.f.geometry.type === 'Point' ? item.f.geometry.coordinates : null;
          if (!coords) {
            offsetNormalFeatures.push({ f: item.f, num: item.num, i: item.i, lat: null, lng: null, isPreferred: false });
            return;
          }
          featureData = {
            f: item.f,
            num: item.num,
            i: item.i,
            lat: coords[1],
            lng: coords[0],
            originalLat: coords[1],
            originalLng: coords[0],
            isPreferred: false
          };
        }
        
        // S√©parer les points privil√©gi√©s des autres
        if (featureData.isPreferred && preferPriority) {
          preferredFeatures.push(featureData);
        } else {
          offsetNormalFeatures.push(featureData);
        }
      });

      // Regrouper les h√©bergements (ordre 0.0) en un seul point unique
      // D'abord, collecter toutes les features par emplacement
      const hebergementByCoord = new Map();
      hebergementFeatures.forEach(function(item) {
        const f = item.f;
        const coords = f.geometry && f.geometry.type === 'Point' ? f.geometry.coordinates : null;
        if (!coords) return;
        const lng = coords[0];
        const lat = coords[1];
        const coordKey = lat.toFixed(6) + ',' + lng.toFixed(6);
        
        if (!hebergementByCoord.has(coordKey)) {
          hebergementByCoord.set(coordKey, []);
        }
        hebergementByCoord.get(coordKey).push(f);
      });
      
      // Pour chaque emplacement, trouver la premi√®re feature avec un lien, sinon prendre la premi√®re
      const hebergementMap = new Map();
      hebergementByCoord.forEach(function(features, coordKey) {
        // Chercher la premi√®re feature avec un URL non vide
        let selectedFeature = features[0];
        let foundUrl = false;
        for (let i = 0; i < features.length; i++) {
          const props = features[i].properties || {};
          const url = props.url;
          // V√©rifier si l'URL existe et n'est pas vide (g√©rer null, undefined, cha√Æne vide)
          if (url !== null && url !== undefined && String(url).trim() !== '') {
            selectedFeature = features[i];
            foundUrl = true;
            break;
          }
        }
        
        const coords = selectedFeature.geometry && selectedFeature.geometry.type === 'Point' ? selectedFeature.geometry.coordinates : null;
        if (!coords) return;
        const lng = coords[0];
        const lat = coords[1];
        
        // S'assurer que les propri√©t√©s incluent bien l'URL si elle a √©t√© trouv√©e
        const finalProps = selectedFeature.properties || {};
        // Si on a trouv√© une feature avec URL, s'assurer que l'URL est bien dans les propri√©t√©s
        if (foundUrl && finalProps.url) {
          // L'URL est d√©j√† dans finalProps, pas besoin de modification
        }
        
        hebergementMap.set(coordKey, {
          f: selectedFeature,
          lat: lat,
          lng: lng,
          props: finalProps
        });
      });

      const group = L.featureGroup();

      // Fonction helper pour cr√©er un marqueur
      function createMarker(item, zIndexOffset) {
        const f = item.f;
        const num = item.num;
        const lat = item.lat;
        const lng = item.lng;
        if (lat === null || lng === null) return null;
        
        const props = f.properties || {};
        const priorite = props.priorite || '';
        const prioInfo = prioClass(priorite);
        const cls = prioInfo.cls;

        const iconHtml = '<div class="num-marker ' + cls + '">' + esc(num) + '</div>';
        const icon = L.divIcon({
          className: '',
          html: iconHtml,
          iconSize: [32, 32],
          iconAnchor: [16, 32],  // anchor bottom middle
          popupAnchor: [0, -28]
        });

        const marker = L.marker([lat, lng], { icon: icon });
        if (zIndexOffset) {
          marker.setZIndexOffset(zIndexOffset);
        }
        marker.bindPopup(makePopup(props, num), { maxWidth: 320 });
        
        // Enregistrer le marqueur pour le routage interactif
        if (typeof registerVisitMarkerForRouting === 'function') {
          registerVisitMarkerForRouting(marker, f);
        }
        
        return marker;
      }
      
      // Ajouter d'abord les points normaux (d√©cal√©s ou isol√©s)
      offsetNormalFeatures.forEach(function(item) {
        const marker = createMarker(item, 0);
        if (marker) {
          marker.addTo(group);
        }
      });
      
      // Ajouter ensuite les points privil√©gi√©s et les placer au-dessus
      const PRIORITY_Z_INDEX = 500; // Z-index pour les points privil√©gi√©s dans les groupes proches
      const preferredMarkers = [];
      preferredFeatures.forEach(function(item) {
        const marker = createMarker(item, PRIORITY_Z_INDEX);
        if (marker) {
          if (DEBUG_MODE) {
            console.log(`[DEBUG] Point privil√©gi√© ${item.num} ajout√© avec z-index ${PRIORITY_Z_INDEX}`);
          }
          marker.addTo(group);
          preferredMarkers.push(marker);
        }
      });

      // Ajouter les points d'h√©bergement (un seul par emplacement)
      hebergementMap.forEach(function(hebergement) {
        const props = hebergement.props;
        const lat = hebergement.lat;
        const lng = hebergement.lng;
        
        // Ic√¥ne d'habitation pour l'h√©bergement
        const iconHtml = '<div class="hebergement-marker">üè†</div>';
        const icon = L.divIcon({
          className: '',
          html: iconHtml,
          iconSize: [40, 40],
          iconAnchor: [20, 40],  // anchor bottom middle
          popupAnchor: [0, -35]
        });

        const marker = L.marker([lat, lng], { icon: icon });
        marker.bindPopup(makePopup(props, '0.0'), { maxWidth: 320 });
        
        // Enregistrer le marqueur d'h√©bergement pour le routage interactif
        if (typeof registerVisitMarkerForRouting === 'function' && hebergement.f) {
          registerVisitMarkerForRouting(marker, hebergement.f);
        }
        
        marker.addTo(group);
      });
      

      group.addTo(map);
      
      // Forcer les points privil√©gi√©s √† √™tre au-dessus
      // Dans Leaflet, on doit r√©organiser les layers du groupe pour mettre les privil√©gi√©s en dernier
      // Le dernier layer ajout√© au groupe sera au-dessus visuellement
      if (preferredMarkers.length > 0) {
        preferredMarkers.forEach(function(marker) {
          // Retirer le marqueur du groupe
          group.removeLayer(marker);
          // Le r√©ajouter en dernier (ce qui le place au-dessus)
          group.addLayer(marker);
          if (DEBUG_MODE) {
            const popup = marker.getPopup();
            const content = popup ? popup.getContent() : '';
            const numMatch = content.match(/(\d+\.\d+)/);
            const num = numMatch ? numMatch[0] : '?';
            console.log(`[DEBUG] Point privil√©gi√© ${num} forc√© au premier plan en le r√©ajoutant au groupe`);
          }
        });
      }

      // Zoom sur l'ensemble des points (avec marge)
      const b = group.getBounds();
      if (b.isValid()) {
        map.fitBounds(b.pad(0.15));
        
        // V√©rifier la visibilit√© des points prioritaires apr√®s le zoom
        if (typeof priorityMarkers !== 'undefined' && priorityMarkers.length > 0) {
          priorityMarkers.forEach(function(marker) {
            const markerBounds = L.latLngBounds([marker.getLatLng()]);
            const isVisible = b.contains(markerBounds);
            if (!isVisible) {
              // Centrer la carte sur le point prioritaire si n√©cessaire
              map.setView(marker.getLatLng(), 15);
            }
          });
        }
      } else {
        map.setView([41.9028, 12.4964], 12); // Rome fallback
      }
    }

    loadGeoJson().catch(err => {
      console.error(err);
      alert("Erreur : " + err.message);
      map.setView([41.9028, 12.4964], 12);
    });
  </script>
</body>
</html>